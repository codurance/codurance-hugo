<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Long Classes/Methods on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/long-classes/methods/</link>
    <description>Recent content in Long Classes/Methods on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Thu, 17 Mar 2016 12:10:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/long-classes/methods/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Code Smells – Part I</title>
      <link>http://codurance.com/blog/code-smells-part-one/</link>
      <pubDate>Thu, 17 Mar 2016 12:10:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/code-smells-part-one/</guid>
      <description>

&lt;p&gt;Last weekend I was at &lt;a href=&#34;https://twitter.com/hashtag/socracan16&#34;&gt;SoCraTes Canaries&lt;/a&gt; and I gave my first talk ever about code smells. Oh boy! How nervous was I! But now that has passed, I was wondering what I should do with all information I gathered. And then I thought, maybe it&amp;rsquo;s a good idea to put it all in a nice blog post.&lt;/p&gt;

&lt;h2 id=&#34;so-what-are-code-smells&#34;&gt;So what are code smells?&lt;/h2&gt;

&lt;p&gt;As &lt;a href=&#34;http://martinfowler.com/&#34;&gt;Martin Fowler&lt;/a&gt; said in his book &lt;a href=&#34;http://martinfowler.com/books/refactoring.html&#34;&gt;&amp;ldquo;Refactoring: Improving the Design of Existing Code&amp;rdquo;&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;A code smell is a surface indication that usually corresponds to a deeper problem in the system.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I like to think that a code smell is something that makes your developer instinct cry out to you, and you just know that something is wrong. This doesn’t mean you have to make changes in your code: there are occasions where these code smells are ok, but I think it’s important for us to detect them and know exactly why they are there.&lt;/p&gt;

&lt;p&gt;There are five categories of code smells:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bloaters&lt;/li&gt;
&lt;li&gt;Object-Orientation Abusers&lt;/li&gt;
&lt;li&gt;Change Preventers&lt;/li&gt;
&lt;li&gt;Dispensables&lt;/li&gt;
&lt;li&gt;Couplers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today I&amp;rsquo;m going to talk about Bloaters. I&amp;rsquo;ll leave the other categories for a future post.&lt;/p&gt;

&lt;h2 id=&#34;bloaters&#34;&gt;Bloaters&lt;/h2&gt;

&lt;p&gt;Bloaters can be big methods or classes, primitive obsessions, data clumps, or long parameter lists.&lt;/p&gt;

&lt;h4 id=&#34;long-parameter-list-data-clumps&#34;&gt;Long Parameter List/Data Clumps&lt;/h4&gt;

&lt;p&gt;The Long Parameter List is when you have a method that has more than 3 parameters. Sometimes we see that when we receive an object, and instead of passing it all we pass some of its data. In this case, the best policy is to pass the whole object. Data Clumps are a bit different: they are, in general, primitive values that start to &amp;ldquo;get together&amp;rdquo;. A good example of this is a startDate and endDate&amp;hellip; Maybe it&amp;rsquo;s worth creating a DateRange.&lt;/p&gt;

&lt;h4 id=&#34;primitive-obsession&#34;&gt;Primitive Obsession&lt;/h4&gt;

&lt;p&gt;This case is when we use primitives instead of value types for simple tasks. Sometimes the use of primitives is justifiable, but when you start to have behaviour attached to this primitives, then it&amp;rsquo;s time to stop and think that maybe a value type is in order. A simple example is a currency: we tend to put it in a float or double, instead of encapsulating it in a value type.&lt;/p&gt;

&lt;h4 id=&#34;long-method-large-class&#34;&gt;Long Method / Large Class&lt;/h4&gt;

&lt;p&gt;This kind of code smell happens when you have a big method. But when do you know that a method has become too big? Well, I have the rule that with more than five lines, you should, at least, look at it again. But, as &lt;a href=&#34;https://twitter.com/sandromancuso&#34;&gt;Sandro&lt;/a&gt; told me before, the right number of lines is just enough lines so a method only does one thing (and so it conforms to the 1st principle of &lt;a href=&#34;https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&#34;&gt;SOLID&lt;/a&gt; the &lt;a href=&#34;https://en.wikipedia.org/wiki/Single_responsibility_principle&#34;&gt;Single responsibility principle&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;To do this blog I started to look at my old code when I hadn&amp;rsquo;t woken up yet to craftsmanship: if it was working that was good enough for me. Here&amp;rsquo;s the code in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void) postToServer
{
    PostSerializer* postSerializer = [[PostSerializer alloc] init];
    NSString *post = [postSerializer serializePostWithTitle:self.txtTitle.text description:self.txtDescription.text author:self.txtUser.text game:self.game];

    NSMutableDictionary *postParams = [NSMutableDictionary dictionary];
	  [postParams setObject:txtTitle.text forKey:@&amp;quot;title&amp;quot;];
	  [postParams setObject:post forKey:@&amp;quot;data&amp;quot;];
	  [postParams setObject:txtUser.text forKey:@&amp;quot;username&amp;quot;];
    [postParams setObject:txtPassword.text forKey:@&amp;quot;password&amp;quot;];

	  NSArray *args = [NSArray arrayWithObjects:[NSNumber numberWithInt:0], postParams, nil];

#ifdef DEBUG_LOG
    XMLRPCRequest *request = [[XMLRPCRequest alloc] initWithURL:
                              [NSURL URLWithString:@&amp;quot;http://localhost:8888/letsbasket/xmlrpc.php&amp;quot;]];
    DLog(@&amp;quot;Debug&amp;quot;);
#else
    XMLRPCRequest *request = [[XMLRPCRequest alloc] initWithURL:[NSURL URLWithString:[UtilsHelper localizeString:@&amp;quot;UrlXmlRPCKey&amp;quot;]]];
    DLog(@&amp;quot;Producao&amp;quot;);
#endif

	  [request setMethod:@&amp;quot;letsBasket.AddPost&amp;quot; withParameters:args];

    NSError *error = nil;
	  XMLRPCResponse* result = [XMLRPCConnection sendSynchronousXMLRPCRequest:request error:&amp;amp;error];

    UIApplication *app = [UIApplication sharedApplication];
    app.networkActivityIndicatorVisible = NO;

    [self dismissWaitingAlert];

    if(error != nil || [[result body] rangeOfString:@&amp;quot;&amp;lt;name&amp;gt;error&amp;lt;/name&amp;gt;&amp;quot;].location != NSNotFound)
    {
        int location_start = [[result body] rangeOfString:@&amp;quot;&amp;lt;string&amp;gt;&amp;quot;].location + 8;
        int location_end = [[result body] rangeOfString:@&amp;quot;&amp;lt;/string&amp;gt;&amp;quot;].location;

        NSString *message = [[[result body] substringWithRange:NSMakeRange(location_start, location_end- location_start)] unescapedString];
        NSString* title = [UtilsHelper localizeString:@&amp;quot;PublishVC_ErrorRetreivingAlertTitle_key&amp;quot;];
        [self showAlertWithErrorMessage:message Title:title];
	      return;
	  }

    [self processPublishResult:result];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow! This is a really big method. And it is inside a ViewController class, so this should definitely be extracted into a service class, so we have a correct separation of concerns. But for the sake of the brevity, let&amp;rsquo;s focus on how can we refactor this big method.
The refactoring technique to apply here is &lt;strong&gt;Extract Method&lt;/strong&gt;: you can aggregate code together and extract to a new method. So let&amp;rsquo;s see what we can come up with:&lt;/p&gt;

&lt;p&gt;We can start with grouping the code that refers to serializing a post:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (NSString *)serializePost
{
    PostSerializer* postSerializer = [[PostSerializer alloc] init];
    NSString *post = [postSerializer serializePostWithTitle:self.txtTitle.text description:self.txtDescription.text author:self.txtUser.text game:self.game];
    return post;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can do it for the parameters of the request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (NSArray *)createPostParams:(NSString *)post
{
    NSMutableDictionary *postParams = [NSMutableDictionary dictionary];
    [postParams setObject:txtTitle.text forKey:@&amp;quot;title&amp;quot;];
    [postParams setObject:post forKey:@&amp;quot;data&amp;quot;];
    [postParams setObject:txtUser.text forKey:@&amp;quot;username&amp;quot;];
    [postParams setObject:txtPassword.text forKey:@&amp;quot;password&amp;quot;];

    NSArray *args = [NSArray arrayWithObjects:[NSNumber numberWithInt:0], postParams, nil];
    return args;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With all this in place we are now ready to create a XMLRPCRequest:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (XMLRPCRequest *)createXMLRPCRequestWithArgs:(NSArray*)args {

    XMLRPCRequest *request;

#ifdef DEBUG_LOG
   request = [[XMLRPCRequest alloc] initWithURL:
                              [NSURL URLWithString:@&amp;quot;http://localhost:8888/letsbasket/xmlrpc.php&amp;quot;]];
    DLog(@&amp;quot;Debug&amp;quot;);
#else
    request = [[XMLRPCRequest alloc] initWithURL:[NSURL URLWithString:[UtilsHelper localizeString:@&amp;quot;UrlXmlRPCKey&amp;quot;]]];
    DLog(@&amp;quot;Producao&amp;quot;);
#endif

    [request setMethod:@&amp;quot;letsBasket.AddPost&amp;quot; withParameters:args];

    return request;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also extract a method with some display updates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)updateDisplay
{
    UIApplication *app = [UIApplication sharedApplication];
    app.networkActivityIndicatorVisible = NO;

    [self dismissWaitingAlert];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last but not least we can extract the preparation for displaying the error message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)showError:(NSString*)bodyResult {

    int location_start = [bodyResult rangeOfString:@&amp;quot;&amp;lt;string&amp;gt;&amp;quot;].location + 8;
    int location_end = [bodyResult rangeOfString:@&amp;quot;&amp;lt;/string&amp;gt;&amp;quot;].location;

    NSString *message = [[bodyResult substringWithRange:NSMakeRange(location_start, location_end- location_start)] unescapedString];
    NSString* title = [UtilsHelper localizeString:@&amp;quot;PublishVC_ErrorRetreivingAlertTitle_key&amp;quot;];
    [self showAlertWithErrorMessage:message Title:title];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With all these extractions our method now looks pretty neat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void) postToServer
{
    NSString *post = [self serializePost];
    NSArray *args = [self createPostParams:post];
    XMLRPCRequest *request = [self createXMLRPCRequestWithArgs: args];
    NSError *error = nil;

	  XMLRPCResponse* result = [XMLRPCConnection sendSynchronousXMLRPCRequest:request error:&amp;amp;error];

    [self updateDisplay];

    if(error != nil || [[result body] rangeOfString:@&amp;quot;&amp;lt;name&amp;gt;error&amp;lt;/name&amp;gt;&amp;quot;].location != NSNotFound)
    {
        [self showError:[result body]];
		    return;
	  }

    [self processPublishResult:result];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm&amp;hellip; we can do this even better! Let&amp;rsquo;s take a look at the method &lt;code&gt;createXMLRCPRequest&lt;/code&gt; and see if we can call the others from there. In this case, it makes sense to have all together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (XMLRPCRequest *)createXMLRPCRequest {

    NSString *post = [self serializePost];
    NSArray *args = [self createPostParams:post];

    XMLRPCRequest *request;

#ifdef DEBUG_LOG
   request = [[XMLRPCRequest alloc] initWithURL:
                              [NSURL URLWithString:@&amp;quot;http://localhost:8888/letsbasket/xmlrpc.php&amp;quot;]];
    DLog(@&amp;quot;Debug&amp;quot;);
#else
    request = [[XMLRPCRequest alloc] initWithURL:[NSURL URLWithString:[UtilsHelper localizeString:@&amp;quot;UrlXmlRPCKey&amp;quot;]]];
    DLog(@&amp;quot;Producao&amp;quot;);
#endif

    [request setMethod:@&amp;quot;letsBasket.AddPost&amp;quot; withParameters:args];

    return request;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our original method now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void) postToServer
{
    XMLRPCRequest *request = [self createXMLRPCRequest];
    NSError *error = nil;

    XMLRPCResponse* result = [XMLRPCConnection sendSynchronousXMLRPCRequest:request error:&amp;amp;error];

    [self updateDisplay];

    if(error != nil || [[result body] rangeOfString:@&amp;quot;&amp;lt;name&amp;gt;error&amp;lt;/name&amp;gt;&amp;quot;].location != NSNotFound)
    {
        [self showError:[result body]];
        return;
    }

    [self processPublishResult:result];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, here you go: a method with more than 5 lines and I think that&amp;rsquo;s ok. :)
As we can see it&amp;rsquo;s really easy to let a method grow. But it&amp;rsquo;s really easy to refactor and have a cleaner code too.&lt;/p&gt;

&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;In general, bloaters are viewed as code that, over time, &amp;ldquo;gets out of hand&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Remember, code smells sometimes can&amp;rsquo;t be removed, but it&amp;rsquo;s good to know that they are there and you know &lt;strong&gt;why&lt;/strong&gt; they are there.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>