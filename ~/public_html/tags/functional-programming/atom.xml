<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/functional-programming/</link>
    <description>Recent content in Functional Programming on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sat, 30 Apr 2016 00:20:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/functional-programming/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Akka basics</title>
      <link>http://codurance.com/blog/Akka-basics/</link>
      <pubDate>Sat, 30 Apr 2016 00:20:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/Akka-basics/</guid>
      <description>

&lt;p&gt;As &lt;a href=&#34;http://codurance.com/2016/04/28/async-systems-with-sync-clients&#34;&gt;the previous post&lt;/a&gt; explained our system is based on &lt;a href=&#34;http://akka.io/&#34;&gt;Akka&lt;/a&gt;. Before going into more detail about our solution, I&amp;rsquo;d like to explain what Akka is about and why it is so awesome.&lt;/p&gt;

&lt;p&gt;Akka is a toolkit and not a framework, you can simply use the bits that you need for your service. In this series we&amp;rsquo;ll focus on the core features and we won&amp;rsquo;t go through &lt;a href=&#34;http://doc.akka.io/docs/akka/2.4.4/scala/stream/index.html&#34;&gt;Akka Streams&lt;/a&gt;, &lt;a href=&#34;http://doc.akka.io/docs/akka/2.4.4/scala/http/index.html&#34;&gt;Akka-Http&lt;/a&gt; or &lt;a href=&#34;http://doc.akka.io/docs/akka/2.4.4/common/cluster.html&#34;&gt;Akka Cluster&lt;/a&gt; (since they&amp;rsquo;re out of scope, not because they&amp;rsquo;re not fantastic).&lt;/p&gt;

&lt;p&gt;Akka provides a different abstraction to deal with concurrency, paralellism and fault-tolerance. That abstraction is called Actor Model. If you have experience with the old Java ecosystem you will know how hard it is to &lt;a href=&#34;http://codurance.com/2015/12/13/testing-multithreaded-code-in-java/&#34;&gt;write safe and correct multithreaded code&lt;/a&gt;. Providing human-friendly abstractions like Actors is a revolution comparable to Java&amp;rsquo;s memory management at the time of introduction. New challenges derived from internet scale and cloud computing requires a reactive approach to programming. Akka aligns with that philosophy and enables you to implement &lt;a href=&#34;https://www.wikiwand.com/en/Event-driven_architecture&#34;&gt;Event-driven architectures&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;actors-all-the-way&#34;&gt;Actors all the way&lt;/h2&gt;

&lt;p&gt;Threads are an expensive resource, hence we need to use them judiciously. Blocking threads while we&amp;rsquo;re waiting for some I/O operation to respond is really inefficient. Actors use threads in a different way, as a result of which they&amp;rsquo;re pretty lightweight (&lt;a href=&#34;http://doc.akka.io/docs/akka/2.4.4/intro/what-is-akka.html&#34;&gt;several million actors per GB of heap memory&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Actors are a good blend of Object Oriented and Functional Programming principles. OOP is basically about messages as Alan Kay, one of the pioneers of OOP, &lt;a href=&#34;http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html&#34;&gt;stated&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m sorry that I long ago coined the term &amp;ldquo;objects&amp;rdquo; for this topic because it gets many people to focus on the lesser idea. The big idea is &amp;ldquo;messaging&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An actor exchanges immutable messages and keeps their own encapsulated state: every interaction needs to be done through messages.&lt;/p&gt;

&lt;h2 id=&#34;fault-tolerance&#34;&gt;Fault tolerance&lt;/h2&gt;

&lt;p&gt;There is not a clear and shared error handling model in Java, and you can realise that after working in a couple of projects. The origin of that is a confusing abstraction called Exception and its subtypes Checked and Unchecked Exceptions. The only real difference is that checked exceptions force us to deal with the issue in the direct caller, except for that they don&amp;rsquo;t hint at the strategy that we should apply.&lt;/p&gt;

&lt;p&gt;I strongly recommend &lt;a href=&#34;http://joeduffyblog.com/2016/02/07/the-error-model/&#34;&gt;this&lt;/a&gt; post about it. One such powerful idea in the post is that bugs aren&amp;rsquo;t recoverable errors. This quote is contained in that post, &lt;a href=&#34;https://wiki.haskell.org/Error_vs._Exception&#34;&gt;original source&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I was involved in the development of a library that was written in C++. One of the developers told me that the developers are divided into the ones who like exceptions and the other ones who prefer return codes. As it seems to me, the friends of return codes won. However, I got the impression that they debated on the wrong point: Exceptions and return codes are equally expressive, they should however not be used to describe errors. Actually the return codes contained definitions like &lt;code&gt;ARRAY_INDEX_OUT_OF_RANGE&lt;/code&gt;. But I wondered: How shall my function react, when it gets this return code from a subroutine? Shall it send a mail to its programmer? It could return this code to its caller in turn, but it will also not know how to cope with it. Even worse, since I cannot make assumptions about the implementation of a function, I have to expect an &lt;code&gt;ARRAY_INDEX_OUT_OF_RANGE&lt;/code&gt; from every subroutine. My conclusion is that &lt;code&gt;ARRAY_INDEX_OUT_OF_RANGE&lt;/code&gt; is a (programming) error. It cannot be handled or fixed at runtime, it can only be fixed by its developer. Thus there should be no according return code, but instead there should be asserts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Akka provides a great way for dealing with failures/errors based on these tenets:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Single responsibility principle: failure management is delegated to supervisors, creating focused business actors. We agreed some time ago that lifecycle management, e.g. object creation, should be moved to factories, therefore an object is not responsible for creating itself. Resuming or restarting an object, after some failure happened, is part of that lifecycle management and Akka enforces you to move that responsibility to supervisors. The resulting code will be loosely coupled and highly cohesive.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Default recovery strategies: it&amp;rsquo;s important to understand which are our options after the system is under some failure condition. Is the DB temporarily down? Has some input, in combination with the existing data, created an undesired state? Is that a bug? Do we need to abandon that particular request or that part of the system is messed up until some patch is applied? Those questions will determine our response to that incident, and Akka provides some &lt;a href=&#34;http://doc.akka.io/docs/akka/2.4.4/scala/fault-tolerance.html#fault-tolerance-scala&#34;&gt;built-in strategies&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;override val supervisorStrategy =
  OneForOneStrategy(maxNrOfRetries = 10, withinTimeRange = 1 minute) {
    case _: ArithmeticException      =&amp;gt; Resume
    case _: NullPointerException     =&amp;gt; Restart
    case _: IllegalArgumentException =&amp;gt; Stop
    case _: Exception                =&amp;gt; Escalate
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Failure as first class citizen: some libraries or ecosystems hide failures through obscure APIs. Akka is usually deployed in distributed environments, therefore using unreliable resources like networks. That forces us to bring failure to the front. Even in &amp;lsquo;safer&amp;rsquo; environments as monoliths, failures are all around, so using toolkits like Akka is critical to create reliable and robust software.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;concurrency-and-parallelism&#34;&gt;Concurrency and parallelism&lt;/h2&gt;

&lt;p&gt;With Akka we&amp;rsquo;re not going to deal directly with threads, they&amp;rsquo;re hidden under an abstraction layer. The backbone of an Akka app is the &lt;a href=&#34;http://doc.akka.io/api/akka/2.0/akka/actor/ActorSystem.html&#34;&gt;Actor System&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An actor system is a hierarchical group of actors which share common configuration, e.g. dispatchers, deployments, remote capabilities and addresses. It is also the entry point for creating or looking up actors.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A Dispatcher is also an Execution Context, so in the end it is where the thread pool is located. Let&amp;rsquo;s assume that your app uses a single dispatcher with 4 threads allocated. As you can see threads are a scarce resource, if we do blocking I/O or heavy CPU work in some of the actors we&amp;rsquo;ll use exclusively one of the threads, and you can see how quickly your service will run out of threads.&lt;/p&gt;

&lt;p&gt;The solution is wrapping those operation with constructs like Scala Futures and then provide a different execution context for those tasks.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Akka is a fantastic toolkit full of well suited abstractions for modern problems. In the next post we&amp;rsquo;ll see with the help of some code how to coordinate and supervise actors with the constraints of our example application.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://codurance.com/2016/04/28/async-systems-with-sync-clients/&#34;&gt;Part 1&lt;/a&gt; | &lt;a href=&#34;http://codurance.com/2016/04/30/akka-basics/&#34;&gt;Part 2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Side effects and Java 8 streams</title>
      <link>http://codurance.com/blog/side-effects-and-java-8-streams/</link>
      <pubDate>Mon, 04 May 2015 11:22:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/side-effects-and-java-8-streams/</guid>
      <description>

&lt;p&gt;There is a lot of excitement in the Java community since Java 8 was released. Lambdas and Streams are a massive improvement and nobody wants to go back to the old days. Today, however, I want to talk about the caveats of some use of Java Streams.&lt;/p&gt;

&lt;p&gt;When you start using Streams and its functional capabilities you start seeing your code as some pipeline of computational operations. As you&amp;rsquo;re abstracting low-level concerns as iteration details, you can focus on the rules (business, english-like rules) of your transformations. Then your mindset gets even more abstract (as it usually happens when you have exposure to functional programming) and you realise that almost every piece of application server code that you&amp;rsquo;ve written can be abstracted as a pipeline of transformations in some data that sends messages during the process (aka, side effects).&lt;/p&gt;

&lt;p&gt;Even if we use DDD or any OOP design practice, that key principle stands. Then the temptation to model our whole flow (from Rest adapter to DB or Event Stores) as a single Stream is quite strong. Let&amp;rsquo;s provide an example.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that we have a football league application and we want to check that the day before a match everything is ready to play. Let&amp;rsquo;s see the data in different steps of the pipeline:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Subscribed players&lt;/p&gt;

&lt;p&gt;a. (filter) Check if they&amp;rsquo;re available for the match&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Available players&lt;/p&gt;

&lt;p&gt;a. (map) Create a team&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Team &amp;hellip;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In 1.a we want to send a reminder email to the guys that have marked themselves previously as available and in 2.a we want to store that team in some DB. Those behaviours could and should live in different components, but conceptually that flow is the same stream. We want to use the data to execute the side effects but not consume it, as we want to keep using the stream.&lt;/p&gt;

&lt;h2 id=&#34;understanding-execution-order-with-the-peek-method&#34;&gt;Understanding execution order with the &lt;code&gt;peek&lt;/code&gt; method.&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;peek&lt;/code&gt; is a method in the Java 8 Stream API that allows you to use but not consume the data of an stream. We might think that it&amp;rsquo;s a good idea to use &lt;code&gt;peek&lt;/code&gt; to send messages to EmailAdapter and TeamRepository. The problem with &lt;code&gt;peek&lt;/code&gt; is that it&amp;rsquo;s only executed whenever we do actually consume the stream. The Javadoc provides some clues about that:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This method exists mainly to support debugging additionally performing the provided action on each element as elements are consumed from the resulting stream.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;As elements are consumed&lt;/em&gt; is the key, but it&amp;rsquo;s not obvious the first time you read it. In the provided snippet we can see how &lt;code&gt;peek&lt;/code&gt; is executed only when a final operation (&lt;code&gt;forEach&lt;/code&gt; in this case) is called:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    IntStream stream = createAStreamAndPerformSomeSideEffectWithPeek();
    System.out.println(&amp;quot;Second. I should be the second group of prints&amp;quot;);
    consumeTheStream(stream);
}

private static IntStream createAStreamAndPerformSomeSideEffectWithPeek() {
    return IntStream.of(1, 2, 3)
            .peek(number -&amp;gt; System.out.println(String.format(&amp;quot;First. My number is %d&amp;quot;, number)))
            .map(number -&amp;gt; number + 1);
}

private static void consumeTheStream(IntStream stream) {
    stream.filter(number -&amp;gt; number % 2 == 0)
            .forEach(number -&amp;gt; System.out.println(String.format(&amp;quot;Third. My number is %d&amp;quot;, number)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might expect an output like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First. My number is 1&lt;/li&gt;
&lt;li&gt;First. My number is 2&lt;/li&gt;
&lt;li&gt;First. My number is 3&lt;/li&gt;
&lt;li&gt;Second. I should be the second group of prints&lt;/li&gt;
&lt;li&gt;Third. My number is 2&lt;/li&gt;
&lt;li&gt;Third. My number is 4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When in fact we&amp;rsquo;ll have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Second. I should be the second group of prints&lt;/li&gt;
&lt;li&gt;First. My number is 1&lt;/li&gt;
&lt;li&gt;Third. My number is 2&lt;/li&gt;
&lt;li&gt;First. My number is 2&lt;/li&gt;
&lt;li&gt;First. My number is 3&lt;/li&gt;
&lt;li&gt;Third. My number is 4&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A clever reader could state that the problem was the inclusion of some non-stream operation in the middle of a lazy pipeline. That could be true. For instance when you work in asynchronous code like promises in Node.js is quite important not to mix sequential code with the async chain without a lot of a thought.&lt;/p&gt;

&lt;h2 id=&#34;understanding-laziness-through-optional-api&#34;&gt;Understanding laziness through Optional API.&lt;/h2&gt;

&lt;p&gt;Non-immediate execution using threads, RxJava, streams or any &amp;ldquo;lazy&amp;rdquo; construct could be confusing for a Java developer used to sequential flows. This is a really silly example using Java 8 Optional API that confused me the first time that I saw it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return fetchTrackBy(device).orElse(trackRepository.saveTrackWith(metadata));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fetchTrackBy&lt;/code&gt; returns an Optional so that code could be thought as syntactic sugar. It would unroll to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Track track = fetchTrackBy(device);
if (track.isPresent()) {
    return track.get();
}
return trackRepository.saveTrackWith(metadata);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, there is a bug in the first implementation. Did you spot it? Yes, we&amp;rsquo;re saving the track even if we found it in first place. We&amp;rsquo;d fix it with this implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;return fetchTrackBy(device).orElseGet(() -&amp;gt; trackRepository.saveTrackWith(metadata));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we&amp;rsquo;re providing a lambda (an implementation of the &lt;code&gt;Supplier&lt;/code&gt; functional interface) that will be evaluated lazily if the Optional is not present.&lt;/p&gt;

&lt;h2 id=&#34;other-thoughts-about-streams&#34;&gt;Other thoughts about Streams&lt;/h2&gt;

&lt;p&gt;Coming back to Streams, reading the &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&#34;&gt;Javadoc&lt;/a&gt; seems to be quite useful for our concerns. About side effects:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Side-effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can see an example of a stateful lambda here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Set&amp;lt;Integer&amp;gt; seen = Collections.synchronizedSet(new HashSet&amp;lt;&amp;gt;());
stream.parallel().map(e -&amp;gt; { if (seen.add(e)) return 0; else return e; })
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the visibility of those side-effects to other threads, nor are there any guarantees that different operations on the &amp;ldquo;same&amp;rdquo; element within the same stream pipeline are executed in the same thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is really important to note, but we could say that for our example is not relevant as we want to send messages to external processes with their own concurrency mechanisms. Something more like:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;However, side-effects such as using println() for debugging purposes are usually harmless.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are another problems about using Stream as backbone of our flows. Once a Stream is consumed it&amp;rsquo;s not possible to reuse it again. That means that storing a Stream as a field of some of our domain objects feels like a dangerous idea, as that domain object will be useless once that field is consumed. An idea to mitigate that problem is wrapping that Stream in a Supplier, generating a new stream every time that we request access to that field. This is similar to an &lt;code&gt;Iterable&lt;/code&gt;, which creates a new &lt;code&gt;Iterator&lt;/code&gt; each time the &lt;code&gt;iterator()&lt;/code&gt; method is called.&lt;/p&gt;

&lt;h2 id=&#34;in-conclusion&#34;&gt;In conclusion&lt;/h2&gt;

&lt;p&gt;I would discourage passing around streams in teams with little experience with Java 8. If we decide to apply side effects during the pipeline, I would avoid any side effect that implies some kind of locking or coordination between threads. That said, I would recommend experimenting with these ideas in your spare time, as I found that the best way of learning is by applying &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description&#34;&gt;the core ideas of Java 8 Streams&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;No storage. A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations.&lt;/li&gt;
&lt;li&gt;Functional in nature. An operation on a stream produces a result, but does not modify its source. For example, filtering a Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.&lt;/li&gt;
&lt;li&gt;Laziness-seeking. Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization. For example, &amp;ldquo;find the first String with three consecutive vowels&amp;rdquo; need not examine all the input strings. Stream operations are divided into intermediate (Stream-producing) operations and terminal (value- or side-effect-producing) operations. Intermediate operations are always lazy.&lt;/li&gt;
&lt;li&gt;Possibly unbounded. While collections have a finite size, streams need not. Short-circuiting operations such as limit(n) or findFirst() can allow computations on infinite streams to complete in finite time.&lt;/li&gt;
&lt;li&gt;Consumable. The elements of a stream are only visited once during the life of a stream. Like an Iterator, a new stream must be generated to revisit the same elements of the source.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in the 21st Century: Conclusion</title>
      <link>http://codurance.com/blog/design-patterns-in-the-21st-century-part-five/</link>
      <pubDate>Fri, 17 Apr 2015 18:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/design-patterns-in-the-21st-century-part-five/</guid>
      <description>&lt;p&gt;This is part five of my talk, &lt;a href=&#34;http://talks.samirtalwar.com/design-patterns-in-the-21st-century.html&#34;&gt;Design Patterns in the 21st Century&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Over the past week, we&amp;rsquo;ve seen three examples of design patterns that can be drastically improved by approaching them with a functional mindset. Together, these three span the spectrum.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Abstract Factory pattern is an example of a &lt;strong&gt;creational&lt;/strong&gt; pattern, which increases flexibility during the application wiring process&lt;/li&gt;
&lt;li&gt;The Adapter pattern, a &lt;strong&gt;structural&lt;/strong&gt; pattern, is a huge aid in object composition&lt;/li&gt;
&lt;li&gt;The Chain of Responsibility pattern is a good demonstration of a &lt;strong&gt;behavioural&lt;/strong&gt; &lt;em&gt;anti-pattern&lt;/em&gt; that actually makes the communication between objects &lt;em&gt;more&lt;/em&gt; rigid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We took these three patterns, made them a lot smaller, removed a lot of boilerplate, and knocked out a bunch of extra classes we didn&amp;rsquo;t need in the process.&lt;/p&gt;

&lt;p&gt;In all cases, we split things apart, only defining the coupling between them in the way objects were constructed. But more than that: we made them functional. The difference between domain objects and infrastructural code became much more explicit. This allowed us to generalise, using the built-in interfaces to do most of the heavy lifting for us, allowing us to eradicate lots of infrastructural types and concentrate on our domain.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s funny, all this talk about our business domain. It&amp;rsquo;s almost as if the resulting code became a lot more object-oriented too.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in the 21st Century: The Chain of Responsibility Pattern</title>
      <link>http://codurance.com/blog/design-patterns-in-the-21st-century-part-four/</link>
      <pubDate>Thu, 16 Apr 2015 18:30:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/design-patterns-in-the-21st-century-part-four/</guid>
      <description>

&lt;p&gt;Here&amp;rsquo;s a thing you might not see a lot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void hungryHungryPatrons() {
    KitchenStaff alice = new PieChef();
    KitchenStaff bob = new DollopDistributor();
    KitchenStaff carol = new CutleryAdder();
    KitchenStaff dan = new Server();

    alice.setNext(bob);
    bob.setNext(carol);
    carol.setNext(dan);

    Patron patron = new Patron();
    alice.prepare(new Pie()).forPatron(patron);

    assertThat(patron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It might look odd, but the idea is fairly common. For example, the Java Servlets framework uses the concept of a &lt;code&gt;FilterChain&lt;/code&gt; to model a sequence of filters upon a request.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;Filter&lt;/code&gt; objects to do pretty much anything with a request. Here&amp;rsquo;s one that tracks how many hits there have been to a site. Notice that it passes the &lt;code&gt;request&lt;/code&gt; and &lt;code&gt;response&lt;/code&gt; objects onto the next filter in the chain when it&amp;rsquo;s done.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class HitCounterFilter implements Filter {
    // initialization and destruction methods go here

    public void doFilter(
            ServletRequest request,
            ServletResponse response,
            FilterChain chain)
    {
        int hits = getCounter().incCounter();
        log(“The number of hits is ” + hits);
        chain.doFilter(request, response);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might use an object in the chain to modify the input or output (in this case, the request or response):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class SwitchEncodingFilter implements Filter {
    // initialization and destruction methods go here

    public void doFilter(
            ServletRequest request,
            ServletResponse response,
            FilterChain chain)
    {
        request.setEncoding(“UTF-8”);
        chain.doFilter(request, response);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might even bail out of the chain early if things are going pear-shaped.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class AuthorizationFilter implements Filter {
    // initialization and destruction methods go here

    public void doFilter(
            ServletRequest request,
            ServletResponse response,
            FilterChain chain)
    {
        if (!user().canAccess(request)) {
            throw new AuthException(user);
        }
        chain.doFilter(request, response);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, once you hit an element in the chain, it has full control.&lt;/p&gt;

&lt;p&gt;In UML, it looks a little like this:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/chain-of-responsibility-pattern-uml.png&#34; alt=&#34;Chain of Responsibility pattern UML diagram&#34; title=&#34;Chain of Responsibility pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;h4 id=&#34;this-is-probably-bad-practice&#34;&gt;This is probably bad practice.&lt;/h4&gt;

&lt;p&gt;This may be a little contentious, but I&amp;rsquo;d say that most implementations of the Chain of Responsibility pattern are pretty confusing. Because the chain relies on each and every member playing its part correctly, it&amp;rsquo;s very easy to simply lose things (in the case above, HTTP requests) by missing a line or two, reordering the chain without thinking through the ramifications, or mutating the &lt;code&gt;ServletRequest&lt;/code&gt; in a fashion that makes later elements in the chain misbehave.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive a little further into how we can salvage something from all of this.&lt;/p&gt;

&lt;p&gt;Remember our hungry patron?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    KitchenStaff alice = new PieChef();
    KitchenStaff bob = new DollopDistributor();
    KitchenStaff carol = new CutleryAdder();
    KitchenStaff dan = new Server();

    alice.setNext(bob);
    bob.setNext(carol);
    carol.setNext(dan);

    Patron patron = new Patron();
    alice.prepare(new Pie()).forPatron(patron);

    assertThat(patron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That assertion is using &lt;a href=&#34;https://code.google.com/p/hamcrest/wiki/Tutorial#Sugar&#34;&gt;Hamcrest matchers&lt;/a&gt;, by the way. Check them out if you&amp;rsquo;re not too familiar with them. They&amp;rsquo;re amazing.&lt;/p&gt;

&lt;h4 id=&#34;step-1-stop-mutating&#34;&gt;Step 1: Stop mutating.&lt;/h4&gt;

&lt;p&gt;Not all Chain of Responsibility implementations involve mutation, but for those that do, it&amp;rsquo;s best to get rid of it as soon as possible. Making your code immutable makes it much easier to refactor further without making mistakes.&lt;/p&gt;

&lt;p&gt;There are three cases of mutation here.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each member of staff has the &amp;ldquo;next&amp;rdquo; member set later, and the patrons themselves are mutated. Instead of setting the next member of staff later, we&amp;rsquo;ll construct each one with the next.&lt;/li&gt;
&lt;li&gt;Though you can&amp;rsquo;t see it, Alice, the &lt;code&gt;PieChef&lt;/code&gt;, sets a flag on the &lt;code&gt;Pie&lt;/code&gt; to mark it as &lt;code&gt;cooked&lt;/code&gt; for Bob, the &lt;code&gt;DollopDistributor&lt;/code&gt;. Instead of changing the object, we&amp;rsquo;ll have her accept an &lt;code&gt;UncookedPie&lt;/code&gt; and pass a &lt;code&gt;CookedPie&lt;/code&gt; to Bob. We then adapt Bob to accept a &lt;code&gt;CookedPie&lt;/code&gt;. This ensures we can&amp;rsquo;t get the order wrong, as &lt;code&gt;Bob&lt;/code&gt; will never receive an uncooked pie.&lt;/li&gt;
&lt;li&gt;And as for the patron, we&amp;rsquo;ll start off with a &lt;code&gt;HungryPatron&lt;/code&gt; and have them return a new instance of themselves upon feeding.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    KitchenStaff dan = new Server();
    KitchenStaff carol = new CutleryAdder(dan);
    KitchenStaff bob = new DollopDistributor(carol);
    KitchenStaff alice = new PieChef(bob);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = alice.prepare(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This hasn&amp;rsquo;t changed much, unfortunately. It&amp;rsquo;s still very confusing why we giving the pie to Alice results in the patron receiving it, and we could still get things in the wrong order or ask the wrong person to do something.&lt;/p&gt;

&lt;h4 id=&#34;step-2-make-it-type-safe&#34;&gt;Step 2: Make it type-safe.&lt;/h4&gt;

&lt;p&gt;Part of the problem with the ordering is that even though Alice gives the next person a &lt;code&gt;CookedPie&lt;/code&gt;, we could tell her to give it to anyone, resulting in a &lt;code&gt;ClassCastException&lt;/code&gt; or something equally fun. By parameterising the types, we can avoid this, ensuring that both the input and output types are correct.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    KitchenStaff&amp;lt;WithCutlery&amp;lt;Meal&amp;gt;&amp;gt; dan = new Server();
    KitchenStaff&amp;lt;Meal&amp;gt; carol = new CutleryAdder(dan);
    KitchenStaff&amp;lt;CookedPie&amp;gt; bob = new DollopDistributor(carol);
    KitchenStaff&amp;lt;UncookedPie&amp;gt; alice = new PieChef(bob);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = alice.prepare(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of our constructors will change too. For example, &lt;code&gt;PieChef&lt;/code&gt;&amp;rsquo;s constructor used to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public PieChef(KitchenStaff next) {
    this.next = next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now its parameter specifies the type it accepts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public PieChef(KitchenStaff&amp;lt;CookedPie&amp;gt; next) {
    this.next = next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-separate-behaviours&#34;&gt;Step 3: Separate behaviours.&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;KitchenStaff&lt;/code&gt; does two things: prepare food, but also hand over the food to the next person. Let&amp;rsquo;s split that up into two different concepts. We&amp;rsquo;ll construct an instance of &lt;code&gt;KitchenStaff&lt;/code&gt;, then tell them who to delegate to next.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    KitchenStaff&amp;lt;WithCutlery&amp;lt;Meal&amp;gt;, Serving&amp;gt; dan = new Server();
    KitchenStaff&amp;lt;Meal, Serving&amp;gt; carol = new CutleryAdder().then(dan);
    KitchenStaff&amp;lt;CookedPie, Serving&amp;gt; bob = new DollopDistributor().then(carol);
    KitchenStaff&amp;lt;UncookedPie, Serving&amp;gt; alice = new PieChef().then(bob);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = alice.prepare(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this situation, &lt;code&gt;then&lt;/code&gt; doesn&amp;rsquo;t modify the object directly, but instead returns a new instance of &lt;code&gt;KitchenStaff&lt;/code&gt; who knows to pass it on. It looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static interface KitchenStaff&amp;lt;I, O&amp;gt; {
    O prepare(I input);

    default &amp;lt;Next&amp;gt; KitchenStaff&amp;lt;I, Next&amp;gt; then(KitchenStaff&amp;lt;O, Next&amp;gt; next) {
        return input -&amp;gt; {
            O output = prepare(input);
            return next.prepare(output);
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do this, we also have to return a value rather than operating purely on side effects, ensuring that we &lt;em&gt;always&lt;/em&gt; pass on the value. In situations where we may not want to continue, we can return an &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; value, which can contain either something (&lt;code&gt;Optional.of(value)&lt;/code&gt;) or nothing (&lt;code&gt;Optional.empty()&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;step-4-split-the-domain-from-the-infrastructure&#34;&gt;Step 4: Split the domain from the infrastructure.&lt;/h4&gt;

&lt;p&gt;Now that we have separated the chaining from the construction of the &lt;code&gt;KitchenStaff&lt;/code&gt;, we can separate the two. &lt;code&gt;alice&lt;/code&gt;, &lt;code&gt;bob&lt;/code&gt; and friends are useful objects to know about in their own right, and it&amp;rsquo;s pretty confusing to see them only as part of the chain. Let&amp;rsquo;s leave the chaining until later.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    KitchenStaff&amp;lt;UncookedPie, CookedPie&amp;gt; alice = new PieChef();
    KitchenStaff&amp;lt;CookedPie, Meal&amp;gt; bob = new DollopDistributor();
    KitchenStaff&amp;lt;Meal, WithCutlery&amp;lt;Meal&amp;gt;&amp;gt; carol = new CutleryAdder();
    KitchenStaff&amp;lt;WithCutlery&amp;lt;Meal&amp;gt;, Serving&amp;gt; dan = new Server();

    KitchenStaff&amp;lt;UncookedPie, Serving&amp;gt; staff = alice.then(bob).then(carol).then(dan);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = staff.prepare(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we have a composite object, &lt;code&gt;staff&lt;/code&gt;, which embodies the chain of operations. This allows us to see the individuals as part of it as separate entities.&lt;/p&gt;

&lt;h4 id=&#34;step-5-identify-redundant-infrastructure&#34;&gt;Step 5: Identify redundant infrastructure.&lt;/h4&gt;

&lt;p&gt;That &lt;code&gt;KitchenStaff&lt;/code&gt; type looks awfully familiar at this point.&lt;/p&gt;

&lt;p&gt;Perhaps it looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);

    ...

    default &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; after.apply(apply(t));
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, look, it&amp;rsquo;s a function! And &lt;code&gt;then&lt;/code&gt; is simply function composition. Our &lt;code&gt;KitchenStaff&lt;/code&gt; type appears to be pretty much a subset of the &lt;code&gt;Function&lt;/code&gt; type, so why not just use that instead?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    Function&amp;lt;UncookedPie, CookedPie&amp;gt; alice = new PieChef();
    Function&amp;lt;CookedPie, Meal&amp;gt; bob = new DollopDistributor();
    Function&amp;lt;Meal, WithCutlery&amp;lt;Meal&amp;gt;&amp;gt; carol = new CutleryAdder();
    Function&amp;lt;WithCutlery&amp;lt;Meal&amp;gt;, Serving&amp;gt; dan = new Server();

    Function&amp;lt;UncookedPie, Serving&amp;gt; staff = alice.andThen(bob).andThen(carol).andThen(dan);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = staff.apply(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-6-optionally-replace-classes-with-lambdas-and-method-references&#34;&gt;Step 6: Optionally replace classes with lambdas and method references.&lt;/h4&gt;

&lt;p&gt;Sometimes you really don&amp;rsquo;t need a full class. In this case, the implementation is simple enough that we can just use method references instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void
hungryHungryPatrons() {
    Function&amp;lt;UncookedPie, CookedPie&amp;gt; alice = UncookedPie::cook;
    Function&amp;lt;CookedPie, Meal&amp;gt; bob = CookedPie::addCream;
    Function&amp;lt;Meal, WithCutlery&amp;lt;Meal&amp;gt;&amp;gt; carol = WithCutlery::new;
    Function&amp;lt;WithCutlery&amp;lt;Meal&amp;gt;, Serving&amp;gt; dan = Serving::new;

    Function&amp;lt;UncookedPie, Serving&amp;gt; staff = alice.andThen(bob).andThen(carol).andThen(dan);

    Patron hungryPatron = new HungryPatron();
    Patron happyPatron = staff.apply(new UncookedPie()).forPatron(hungryPatron);

    assertThat(happyPatron, hasPie());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This drastically cuts down on boilerplate and lets us see what&amp;rsquo;s actually going on.&lt;/p&gt;

&lt;p&gt;Our new structure is quite different—far more so than the earlier examples.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/chain-of-responsibility-pattern-uml-functional.png&#34; alt=&#34;Updated Chain of Responsibility pattern UML diagram&#34; title=&#34;Updated Chain of Responsibility pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;By decoupling the business domain (in this case, pie preparation) from the infrastructure (composed functions), we&amp;rsquo;re able to come up with much cleaner, terser code. Our behavioural classes (focusing around preparation) disappeared, leaving only the domain objects themselves (&lt;code&gt;UncookedPie&lt;/code&gt;, for example) and the methods on them (e.g. &lt;code&gt;cook&lt;/code&gt;), which is where the behaviour should probably live anyway.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in the 21st Century: The Adapter Pattern</title>
      <link>http://codurance.com/blog/design-patterns-in-the-21st-century-part-three/</link>
      <pubDate>Wed, 15 Apr 2015 14:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/design-patterns-in-the-21st-century-part-three/</guid>
      <description>&lt;p&gt;This is part three of my talk, &lt;a href=&#34;http://talks.samirtalwar.com/design-patterns-in-the-21st-century.html&#34;&gt;Design Patterns in the 21st Century&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Adapter pattern bridges worlds. In one world, we have an interface for a concept; in another world, we have a different interface. These two interfaces serve different purposes, but sometimes we need to transfer things across. In a well-written universe, we can use &lt;em&gt;adapters&lt;/em&gt; to make objects following one protocol adhere to the other.&lt;/p&gt;

&lt;p&gt;There are two kinds of Adapter pattern. We&amp;rsquo;re not going to talk about this one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Fire {
    &amp;lt;T&amp;gt; Burnt&amp;lt;T&amp;gt; burn(T thing);
}

interface Oven {
    Food cook(Food food);
}

class WoodFire implements Fire { ... }

class MakeshiftOven extends WoodFire implements Oven {
    @Override public Food cook(Food food) {
        Burnt&amp;lt;Food&amp;gt; noms = burn(food);
        return noms.scrapeOffBurntBits();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This form, the &lt;em&gt;class Adapter pattern&lt;/em&gt;, freaks me out, because &lt;code&gt;extends&lt;/code&gt; gives me the heebie jeebies. &lt;em&gt;Why&lt;/em&gt; is out of the scope of this essay; feel free to ask me any time and I&amp;rsquo;ll gladly talk your ears (and probably your nose) off about it.&lt;/p&gt;

&lt;p&gt;Instead, let&amp;rsquo;s talk about the &lt;em&gt;object Adapter pattern&lt;/em&gt;, which is generally considered far more useful and flexible in all regards.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the same class, following this alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MakeshiftOven implements Oven {
    private final Fire fire;

    public MakeshiftOven(Fire fire) {
        this.fire = fire;
    }

    @Override public Food cook(Food food) {
        Burnt&amp;lt;Food&amp;gt; noms = fire.burn(food);
        return noms.scrapeOffBurntBits();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;d use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Oven oven = new MakeshiftOven(fire);
Food bakedPie = oven.cook(pie);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The pattern generally follows this simple structure:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/adapter-pattern-uml.png&#34; alt=&#34;Adapter pattern UML diagram&#34; title=&#34;Adapter pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;That&amp;rsquo;s nice, right?&lt;/p&gt;

&lt;p&gt;Yes. Sort of. We can do better.&lt;/p&gt;

&lt;p&gt;We already have a reference to a &lt;code&gt;Fire&lt;/code&gt;, so constructing another object just to play with it seems a bit… overkill. And that object implements &lt;code&gt;Oven&lt;/code&gt;. Which has a &lt;em&gt;single abstract method&lt;/em&gt;. I&amp;rsquo;m seeing a trend here.&lt;/p&gt;

&lt;p&gt;Instead, we can make a function that does the same thing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Oven oven = food -&amp;gt; fire.burn(food).scrapeOffBurntBits();
Food bakedPie = oven.cook(pie);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could go one further and compose method references, but it actually gets worse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Do *not* do this.
Function&amp;lt;Food, Burnt&amp;lt;Food&amp;gt;&amp;gt; burn = fire::burn;
Function&amp;lt;Food, Food&amp;gt; cook = burn.andThen(Burnt::scrapeOffBurntBits);
Oven oven = cook::apply;
Food bakedPie = oven.cook(pie);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because Java can&amp;rsquo;t convert between functional interfaces implicitly, so we need to give it lots of hints about what each phase of the operation is. Lambdas, on the other hand, are implicitly coercible to any functional interface with the right types, and the compiler does a pretty good job of figuring out how to do it.&lt;/p&gt;

&lt;p&gt;Our new UML diagram will look something like this:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/adapter-pattern-uml-functional.png&#34; alt=&#34;Updated Adapter pattern UML diagram&#34; title=&#34;Updated Adapter pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Often, though, all we really need is a method reference. For example, take the &lt;code&gt;Executor&lt;/code&gt; interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.util.concurrent;

/**
 * An object that executes submitted {@link Runnable} tasks.
 */
public interface Executor {
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It consumes &lt;code&gt;Runnable&lt;/code&gt; objects, and it&amp;rsquo;s a very useful interface.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s say we have one of those, and a bunch of &lt;code&gt;Runnable&lt;/code&gt; tasks, held in a &lt;code&gt;Stream&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Executor executor = ...;
Stream&amp;lt;Runnable&amp;gt; tasks = ...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we execute all of them on our &lt;code&gt;Executor&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;This won&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;tasks.forEach(executor);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It turns out the &lt;code&gt;forEach&lt;/code&gt; method on &lt;code&gt;Stream&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; take a consumer, but a very specific type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Stream&amp;lt;T&amp;gt; {
    ...

    void forEach(Consumer&amp;lt;? super T&amp;gt; action);

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Consumer&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt;
{
    void accept(T t);

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At first glance, that doesn&amp;rsquo;t look so helpful. But note that &lt;code&gt;Consumer&lt;/code&gt; is a functional interface, so we can use lambdas to specify them really easily. That means that we can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;tasks.forEach(task -&amp;gt; executor.execute(task));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which can be simplified further to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;tasks.forEach(executor::execute);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 8 has made adapters so much simpler that I hesitate to call them a pattern any more. The concept is still very important; by explicitly creating adapters, we can keep these two worlds separate except at defined boundary points. The implementations, though? They&amp;rsquo;re just functions.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Tomorrow, we&amp;rsquo;ll be looking at the Chain of Responsibility pattern.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in the 21st Century: The Abstract Factory Pattern</title>
      <link>http://codurance.com/blog/design-patterns-in-the-21st-century-part-two/</link>
      <pubDate>Tue, 14 Apr 2015 10:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/design-patterns-in-the-21st-century-part-two/</guid>
      <description>&lt;p&gt;This is part two of my talk, &lt;a href=&#34;http://talks.samirtalwar.com/design-patterns-in-the-21st-century.html&#34;&gt;Design Patterns in the 21st Century&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This pattern is used &lt;em&gt;everywhere&lt;/em&gt; in Java code, especially in more &amp;ldquo;enterprisey&amp;rdquo; code bases. It involves an interface and an implementation. The interface looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Bakery {
    Pastry bakePastry(Topping topping);
    Cake bakeCake();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DanishBakery implements Bakery {
    @Override public Pastry bakePastry(Topping topping) {
        return new DanishPastry(topping);
    }

    @Override public Cake bakeCake() {
        return new Aeblekage(); // mmmm, apple cake...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More generally, the Abstract Factory pattern is usually implemented according to this structure.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/abstract-factory-pattern-uml.png&#34; alt=&#34;Abstract Factory pattern UML diagram&#34; title=&#34;Abstract Factory pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;In this example, &lt;code&gt;Pastry&lt;/code&gt; and &lt;code&gt;Cake&lt;/code&gt; are &amp;ldquo;abstract products&amp;rdquo;, and &lt;code&gt;Bakery&lt;/code&gt; is an &amp;ldquo;abstract factory&amp;rdquo;. Their implementations are the concrete variants.&lt;/p&gt;

&lt;p&gt;Now, that&amp;rsquo;s a fairly general example.&lt;/p&gt;

&lt;p&gt;In actual fact, most factories only have one &amp;ldquo;create&amp;rdquo; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Bakery {
    Pastry bakePastry(Topping topping);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh look, it&amp;rsquo;s a function.&lt;/p&gt;

&lt;p&gt;This denegerate case is pretty common in in the Abstract Factory pattern, as well as many others. While most of them provide for lots of discrete pieces of functionality, and so have lots of methods, we often tend to break them up into single-method types, either for flexibility or because we just don&amp;rsquo;t need more than one thing at a time.&lt;/p&gt;

&lt;p&gt;So how would we implement this pastry maker?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DanishBakery implements Bakery {
    @Override public Pastry apply(Topping topping) {
        return new DanishPastry(Topping topping);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, sure, that was easy. It looks the same as the earlier &lt;code&gt;DanishBakery&lt;/code&gt; except it can&amp;rsquo;t make cake. Delicious apple cake… what&amp;rsquo;s the point of that?&lt;/p&gt;

&lt;p&gt;Well, if you remember, &lt;code&gt;Bakery&lt;/code&gt; has a &lt;strong&gt;Single Abstract Method&lt;/strong&gt;. This means it&amp;rsquo;s a &lt;strong&gt;Functional Interface&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So what&amp;rsquo;s the functional equivalent to this?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Bakery danishBakery = topping -&amp;gt; new DanishPastry(topping);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or even:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Bakery danishBakery = DanishPastry::new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voila. Our &lt;code&gt;DanishBakery&lt;/code&gt; class has gone.&lt;/p&gt;

&lt;p&gt;But we can go further.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package java.util.function;
/**
 * Represents a function that
 * accepts one argument and produces a result.
 *
 * @since 1.8
 */
@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    /**
     * Applies this function to the given argument.
     */
    R apply(T t);

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can replace the &lt;code&gt;Bakery&lt;/code&gt; with &lt;code&gt;Function&amp;lt;Topping, Pastry&amp;gt;&lt;/code&gt;; they have the same types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Function&amp;lt;Topping, Pastry&amp;gt; danishBakery = DanishPastry::new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we might want to keep it, as it has a name relevant to our business, but often, &lt;code&gt;Factory&lt;/code&gt;-like objects serve no real domain purpose except to help us decouple our code. (&lt;code&gt;UserServiceFactory&lt;/code&gt;, anyone?) This is brilliant, but on these occasions, we don&amp;rsquo;t need explicit classes for it—Java 8 has a bunch of interfaces built in, such as &lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;Supplier&lt;/code&gt; and many more in the &lt;code&gt;java.util.function&lt;/code&gt; package, that suit our needs fairly well.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s our updated UML diagram:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/abstract-factory-pattern-uml-functional.png&#34; alt=&#34;Updated Abstract Factory pattern UML diagram&#34; title=&#34;Updated Abstract Factory pattern UML diagram&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Aaaaaah. Much better.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Tomorrow, we&amp;rsquo;ll be looking at the Adapter pattern.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in the 21st Century, Part One</title>
      <link>http://codurance.com/blog/design-patterns-in-the-21st-century-part-one/</link>
      <pubDate>Mon, 13 Apr 2015 12:30:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/design-patterns-in-the-21st-century-part-one/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been having a bit of trouble blogging recently. In an effort to get back into it, I thought I&amp;rsquo;d take &lt;a href=&#34;http://talks.samirtalwar.com/design-patterns-in-the-21st-century.html&#34;&gt;a talk that I presented at JAX London last year&lt;/a&gt;, split it up into blog-sized posts as it&amp;rsquo;s pretty long, and post them all week. If you haven&amp;rsquo;t read it before or seen the talk, I hope you enjoy it.&lt;/p&gt;

&lt;p&gt;Oh, and if you&amp;rsquo;d rather just read the whole thing in one go, flick through the slides (which are almost entirely code), or watch the recorded version as a video, head to &lt;a href=&#34;http://talks.samirtalwar.com/design-patterns-in-the-21st-century.html&#34;&gt;my talks page&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;what-do-you-want-from-me&#34;&gt;What do you want from me?&lt;/h3&gt;

&lt;p&gt;I want you to stop using design patterns.&lt;/p&gt;

&lt;h3 id=&#34;um&#34;&gt;Um…&lt;/h3&gt;

&lt;p&gt;OK, let me rephrase that.&lt;/p&gt;

&lt;p&gt;I want you to stop using design patterns like it&amp;rsquo;s &lt;em&gt;1999&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;this-is-a-book&#34;&gt;This is a book.&lt;/h2&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-04-13-design-patterns/book.jpg&#34; alt=&#34;Design Patterns, by Gamma, Helm, Johnson and Vlissides&#34; title=&#34;Design Patterns, by Gamma, Helm, Johnson and Vlissides&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;&lt;em&gt;Design Patterns&lt;/em&gt; was a book by the &amp;ldquo;Gang of Four&amp;rdquo;, first published very nearly 20 years ago (at the time of writing this essay), which attempted to canonicalise and formalise the tools that many experienced software developers and designers found themselves using over and over again.&lt;/p&gt;

&lt;p&gt;The originator of the concept (and the term &amp;ldquo;design pattern&amp;rdquo;) was Christopher Alexander, who wasn&amp;rsquo;t a software developer at all. Alexander was an architect who came up with the idea of rigorously documenting common problems in design with their potential solutions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements of this language are entities called patterns. Each pattern describes a problem that occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice. &lt;cite&gt;— Christopher Alexander&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alexander, and the Gang of Four after him, did more than just document solutions to common problems in their respective universes. By naming these patterns and providing a good starting point, they hoped to provide a consistent &lt;em&gt;language&lt;/em&gt;, as well as providing these tools up front so that even novices might benefit from them.&lt;/p&gt;

&lt;h2 id=&#34;and-now-an-aside-on-functional-programming&#34;&gt;And now, an aside, on functional programming.&lt;/h2&gt;

&lt;p&gt;Functional programming is all about &lt;em&gt;&lt;del&gt;functions&lt;/del&gt; &lt;ins&gt;values&lt;/ins&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Values like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int courses = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But also like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Course dessert = prepareCake.madeOf(chocolate);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Preparation prepareCake = new Preparation() {
    @Override
    public Course madeOf(Ingredient deliciousIngredient) {
        return new CakeMix(eggs, butter, sugar)
                .combinedWith(deliciousIngredient);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Preparation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
interface Preparation {
    Course madeOf(Ingredient deliciousIngredient);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So of course, the &lt;code&gt;prepareCake&lt;/code&gt; object could also be written like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Preparation prepareCake =
    deliciousIngredient -&amp;gt;
        new CakeMix(eggs, butter, sugar)
            .combinedWith(deliciousIngredient);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;Preparation&lt;/code&gt; is an interface with a &lt;strong&gt;Single Abstract Method&lt;/strong&gt;, any lambda with the same type signature as &lt;code&gt;Preparation&lt;/code&gt;&amp;rsquo;s method signature can be assigned to an object of type &lt;code&gt;Preparation&lt;/code&gt;. This means that &lt;code&gt;Preparation&lt;/code&gt; is a &lt;strong&gt;functional interface&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;We can go one further. Let&amp;rsquo;s extract that &lt;code&gt;new CakeMix&lt;/code&gt; out. Assuming it&amp;rsquo;s an immutable object with no external dependencies, this shouldn&amp;rsquo;t be a problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Mix mix = new CakeMix(eggs, butter, sugar);
Preparation prepareCake =
    deliciousIngredient -&amp;gt; mix.combinedWith(deliciousIngredient);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can collapse that lambda expression into a method reference.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Mix mix = new CakeMix(eggs, butter, sugar);
Preparation prepareCake = mix::combinedWith;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;well&#34;&gt;Well.&lt;/h3&gt;

&lt;p&gt;Yes. It&amp;rsquo;s weird, but it works out.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re assigning &lt;code&gt;prepareCake&lt;/code&gt; a reference to the &lt;code&gt;combinedWith&lt;/code&gt; method of &lt;code&gt;mix&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mix::combinedWith
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mix::combinedWith&lt;/code&gt; is a &lt;em&gt;method reference&lt;/em&gt;. Its type looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Course combinedWith(Ingredient);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it&amp;rsquo;s (pretty much) exactly the same as &lt;code&gt;deliciousIngredient -&amp;gt; cakeMix.combinedWith(deliciousIngredient)&lt;/code&gt;. That means it conforms to our &lt;code&gt;Preparation&lt;/code&gt; interface above.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Tomorrow, we&amp;rsquo;ll take a look at the first of our design patterns, the Abstract Factory pattern. See you then.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>