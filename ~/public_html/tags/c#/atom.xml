<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/c/</link>
    <description>Recent content in C# on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Fri, 06 May 2016 00:20:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/c" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Language feature envy</title>
      <link>http://codurance.com/blog/language-feature-envy/</link>
      <pubDate>Fri, 06 May 2016 00:20:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/language-feature-envy/</guid>
      <description>

&lt;p&gt;In my day job I mainly write C# code. On my own I like to try other languages like Swift, F#, Clojure, Objective C or Java. I learn a lot from writing code in different languages. When I go back to C# I often miss some of the features C# does not have. By far what I miss the most is Java/Swift enums. It happens quite frequently that I need to express a few finite number of instances of a type. The &lt;a href=&#34;http://snipplr.com/view/42422/the-planet-enum-example/&#34;&gt;Java planets&lt;/a&gt; example illustrates this quite effectively.&lt;/p&gt;

&lt;p&gt;Recently I was porting a music library I wrote in Swift &lt;a href=&#34;https://github.com/pedromsantos/Ellis&#34;&gt;Ellis&lt;/a&gt; to C#. In music there are only 12 notes so using a class to express a musical note feels wrong. Using a enum in C# would be the correct choice&amp;hellip; If I could only add behaviour to enums in C#. Here is an excerpt of the Note enum in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Note: Int
{
    case C = 0
    case CSharp
    case DFlat
    case D
    case DSharp
    case EFlat
    ...

    public func sharp() -&amp;gt; Note
    {
        ...
    }

    public func flat() -&amp;gt; Note
    {
        ...
    }

    public func intervalWithNote(other: Note) -&amp;gt; Interval
    {
        ...
    }

    public func measureAbsoluteSemitones(other: Note) -&amp;gt; Int
    {
        ...
    }

    public func transpose(transposingInterval: Interval) -&amp;gt; Note
    {
      ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that besides being able to define a finite number of instances I&amp;rsquo;m also able to add behaviour to my enum.&lt;/p&gt;

&lt;p&gt;In C# we are stuck with using something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class Note
{
    public static readonly Note C = new Note(Pitch.C, &amp;quot;C&amp;quot;, Accident.None, MinNoteIndex);
    public static readonly Note CSharp = new Note(Pitch.CSharp, &amp;quot;C#&amp;quot;, Accident.Sharp, 1);
    public static readonly Note DFlat = new Note(Pitch.DFlat, &amp;quot;Db&amp;quot;, Accident.Flat, 2);
    public static readonly Note D = new Note(Pitch.D, &amp;quot;D&amp;quot;, Accident.None, 3);
    public static readonly Note DSharp = new Note(Pitch.DSharp, &amp;quot;D#&amp;quot;, Accident.Sharp, 4);
    public static readonly Note EFlat = new Note(Pitch.EFlat, &amp;quot;Eb&amp;quot;, Accident.Flat, 5);
    public static readonly Note E = Note(Pitch.E, &amp;quot;E&amp;quot;, Accident.None, 6);
    public static readonly Note F = new Note(Pitch.F, &amp;quot;F&amp;quot;, Accident.None, 7);
    public static readonly Note FSharp = new Note(Pitch.FSharp, &amp;quot;F#&amp;quot;, Accident.Sharp, 8);
    ...

    private Note(Pitch pitch, string name, Accident accident, int index)
    {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not too bad, but not exactly the same as in Java or Swift.&lt;/p&gt;

&lt;p&gt;There is a feature in Java enums that I still miss for my note implementation in C#, the ordinal method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final int ordinal()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This according to the Java documentation &amp;ldquo;Returns the ordinal of this enumeration constant (its position in its enum declaration, where the initial constant is assigned an ordinal of zero)&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If I want to emulate this behaviour in C# I can do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public static IEnumerable&amp;lt;Note&amp;gt; Notes
{
    get
    {
        yield return C;
        yield return CSharp;
        yield return DFlat;
        yield return D;
        yield return DSharp;
        yield return EFlat;
        yield return E;
        yield return F;
        yield return FSharp;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can access Note instances using an indexer with code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;Note.Notes.ElementAt(indexForNote);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again not ideal but not terrible either. But notice that we are adding up workarounds, all small but it adds up.&lt;/p&gt;

&lt;p&gt;We are getting close to emulate Java/Swift enums in C#. The next step is to emulate the &amp;ldquo;singleton&amp;rdquo; aspect of each instance of the enum. In the current implementation the following line is false in C#:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;Note.C == Note.C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we need is for each instance to be ever unique, AKA the &amp;ldquo;dreadful&amp;rdquo; singleton. This allows us to compare instances without overriding equals and saves us from having potentially thousands of instances representing the same value. After a bit off head scratching I remembered about the Lazy&lt;t&gt; type. That led me to try it in my note implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;public class Note
{
	public static readonly Note C = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.C, &amp;quot;C&amp;quot;, Accident.None, 0)).Value;
	public static readonly Note CSharp = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.CSharp, &amp;quot;C#&amp;quot;, Accident.Sharp, 1)).Value;
	public static readonly Note DFlat = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.DFlat, &amp;quot;Db&amp;quot;, Accident.Flat, 2)).Value;
	public static readonly Note D = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.D, &amp;quot;D&amp;quot;, Accident.None, 3)).Value;
	public static readonly Note DSharp = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.DSharp, &amp;quot;D#&amp;quot;, Accident.Sharp, 4)).Value;
	public static readonly Note EFlat = new Lazy&amp;lt;Note&amp;gt;(() =&amp;gt; new Note(Pitch.EFlat, &amp;quot;Eb&amp;quot;, Accident.Flat, 5)).Value;
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Success the following expression is now true:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;Note.C == Note.C;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to look at the complete implementation it’s on my GitHub &lt;a href=&#34;https://github.com/pedromsantos/Jaco/blob/master/Jaco/Notes/Note.cs&#34;&gt;Jaco.Notes.Note&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;faq&#34;&gt;FAQ:&lt;/h3&gt;

&lt;p&gt;Why don&amp;rsquo;t you create a proposal to have this implemented in C#?&lt;/p&gt;

&lt;p&gt;Nothing is ever original, others have explored that route already.&lt;/p&gt;

&lt;p&gt;Jon Skeet blogged about this in 2006:
&lt;a href=&#34;https://codeblog.jonskeet.uk/2006/01/05/classenum/#comments&#34;&gt;https://codeblog.jonskeet.uk/2006/01/05/classenum/#comments&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are a couple of discussions on Roslyn GitHub:
&lt;a href=&#34;https://github.com/dotnet/roslyn/issues/6739&#34;&gt;https://github.com/dotnet/roslyn/issues/6739&lt;/a&gt;
&lt;a href=&#34;https://github.com/dotnet/roslyn/issues/3704&#34;&gt;https://github.com/dotnet/roslyn/issues/3704&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The only problem is this patent may prevent other languages from having the same behaviour Java has on enums:
&lt;a href=&#34;https://www.google.com/patents/US7263687&#34;&gt;https://www.google.com/patents/US7263687&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multiple projects in Visual Studio solutions considered harmful</title>
      <link>http://codurance.com/blog/visual-studio-projects/</link>
      <pubDate>Mon, 23 Mar 2015 22:49:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/visual-studio-projects/</guid>
      <description>

&lt;h1 id=&#34;multiple-projects-in-visual-studio-solutions-considered-harmful&#34;&gt;Multiple projects in Visual Studio solutions considered harmful&lt;/h1&gt;

&lt;p&gt;I agree with &lt;a href=&#34;https://lostechies.com/chadmyers/author/chadmyers/&#34;&gt;Chad Myers&lt;/a&gt; when he defines a common project anti-pattern &lt;a href=&#34;https://lostechies.com/chadmyers/2008/07/16/project-anti-pattern-many-projects-in-a-visual-studio-solution-file/&#34;&gt;“Many projects in a Visual Studio Solution”&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;fast-feedback-loop&#34;&gt;Fast feedback loop&lt;/h2&gt;

&lt;p&gt;Too many projects increase both the load and build time of your solution. Also a solution will take longer to start executing in debug due the overhead of loading/resolving multiple assemblies with associated PDB’s and symbols. This has an impact on the fast feedback loop we should strive to achieve. When I write code I want feedback as fast as possible. This includes compiling, and executing tests. Solutions with multiple projects affect the fast feedback loop.&lt;/p&gt;

&lt;h2 id=&#34;logical-boundary-physical-boundary&#34;&gt;Logical boundary != Physical boundary&lt;/h2&gt;

&lt;p&gt;An assembly is a unit of deployment in .Net. A Visual Studio project has a 1 on 1 relation with an assembly. We should have boundaries in our solutions, but we should not confuse logical boundaries with physical boundaries. A project in Visual Studio creates a physical boundary; this is often needed, but also open to abuse. Physical boundaries are all about deployment and versioning. If you are not deploying and versioning a part of your code independently, there is no reason to create a physical boundary. Multiple layers != multiple assemblies.&lt;/p&gt;

&lt;h2 id=&#34;dependency-management&#34;&gt;Dependency management&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t want to reference System.Web across all code, so I create a separate assembly where I &amp;ldquo;isolate&amp;rdquo; the code that depends on that assembly. When I hear this argument, most of the time it equates to distrust among team members. Or, I don&amp;rsquo;t trust other developers, so to avoid them referencing System.Web on business classes, I segregate them in another project that does not reference System.Web. Can you hear yourself? There may be a compelling reason to isolate a dependency in a separate assembly, but the reason should not be: to avoid other developers making a mess.&lt;/p&gt;

&lt;h2 id=&#34;how-do-i-do-it&#34;&gt;How do I do it?&lt;/h2&gt;

&lt;p&gt;My solutions start with two projects one for production code and one for tests. The question to ask before creating a project is: Do I need to deploy and version this part of the code independently? Only if the answer is yes do I create a new project.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This subject has been discussed in the community for a long time but I still don’t see any change. I’m continuously faced with solutions with dozens even hundreds of projects. In fact I would say this is the norm, unfortunately. I still see shocked faces, when I propose rearranging a solution using folders and namespaces instead of projects. So I’m adding my voice to other voices.&lt;/p&gt;

&lt;p&gt;Some authors propose a number between 15-20 maximum projects in a Visual Studio Solution to be a good compromise. I disagree; my proposal is one for production code and a separate project for tests. Adding any other project to a solution should be considered very carefully.&lt;/p&gt;

&lt;p&gt;Thanks to Tom Male and Eric Li Koo for reading drafts of this.&lt;/p&gt;

&lt;h4 id=&#34;references&#34;&gt;References&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://ayende.com/blog/3158/the-two-project-solution&#34;&gt;http://ayende.com/blog/3158/the-two-project-solution&lt;/a&gt;
&lt;a href=&#34;http://geekswithblogs.net/FrostRed/archive/2008/10/03/125628.aspx&#34;&gt;http://geekswithblogs.net/FrostRed/archive/2008/10/03/125628.aspx&lt;/a&gt;
&lt;a href=&#34;http://codebetter.com/jeremymiller/2008/09/30/separate-assemblies-loose-coupling/&#34;&gt;http://codebetter.com/jeremymiller/2008/09/30/separate-assemblies-loose-coupling/&lt;/a&gt;
&lt;a href=&#34;http://www.hanselman.com/blog/AssemblyFiefdomsWhatsTheRightNumberOfAssembliesLibraries.aspx&#34;&gt;http://www.hanselman.com/blog/AssemblyFiefdomsWhatsTheRightNumberOfAssembliesLibraries.aspx &lt;/a&gt;
&lt;a href=&#34;https://lostechies.com/chadmyers/2008/07/16/project-anti-pattern-many-projects-in-a-visual-studio-solution-file/&#34;&gt;https://lostechies.com/chadmyers/2008/07/16/project-anti-pattern-many-projects-in-a-visual-studio-solution-file/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>