<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scalatra on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/scalatra/</link>
    <description>Recent content in Scalatra on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 22 Nov 2015 23:54:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/scalatra/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Changing Scalatra and sbt default directories</title>
      <link>http://codurance.com/blog/changing-scalatra-and-sbt-default-directories/</link>
      <pubDate>Sun, 22 Nov 2015 23:54:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/changing-scalatra-and-sbt-default-directories/</guid>
      <description>&lt;p&gt;Conventions are not always good. I recently started a new internal web project
at Codurance and I decided to use Scala. As I&amp;rsquo;m not a fan of big
frameworks, I chose &lt;a href=&#34;http://www.scalatra.org/&#34;&gt;Scalatra&lt;/a&gt; as a micro web framework.&lt;/p&gt;

&lt;p&gt;The first challenge was that I wanted to organise my application with a
different directory structure. By default, &lt;a href=&#34;http://www.scala-sbt.org/&#34;&gt;sbt&lt;/a&gt; and Scalatra use the same convention used by &lt;a href=&#34;https://maven.apache.org/&#34;&gt;maven&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; /src/main/scala       // source code
&amp;gt; /src/main/resources   // production resources
&amp;gt; /scr/test/scala       // tests
&amp;gt; /scr/test/resouces    // test resources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the past few years I&amp;rsquo;ve been experimenting with different directory structure for my projects. I want my directories to be more meaningful when it comes to explain the business domain. The new directory structure is part of what I call &lt;em&gt;Interaction Driven Design (IDD)&lt;/em&gt; and a full talk on it can be found in our &lt;a href=&#34;http://codurance.com/videos/&#34;&gt;videos area&lt;/a&gt;. I give a lot of details about the rational behind the new directory structure on that talk.&lt;/p&gt;

&lt;p&gt;The directory structure I would like to use for this new project is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; /src/core/scala          // source code for my core domain
&amp;gt; /src/core-test/scala     // tests for my core domain

&amp;gt; /src/data/resources      // resources for data migration and test data
&amp;gt; /src/data/scala          // code for data migration and test data

&amp;gt; /src/web/resources       // delivery mechanism resources
&amp;gt; /src/web/scala           // delivery mechanism code (controllers, API, etc)
&amp;gt; /src/web/webapp          // web files (WEB-INF folder, css, javascript, Jade templates, etc)
&amp;gt; /src/web-test/scala      // tests for my delivery mechanism
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, the directory structure above will make more sense if you watch the &lt;a href=&#34;http://codurance.com/videos/&#34;&gt;Interaction Driven Design (IDD) talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The biggest challenge was to rename the default directory &lt;em&gt;main&lt;/em&gt; to &lt;em&gt;web&lt;/em&gt;. That broke the whole world. Here are the changes I had to make to fix it all:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;unmanagedSourceDirectories in Compile := Seq((baseDirectory.value / &amp;quot;src/core/scala&amp;quot;),
                                     (baseDirectory.value / &amp;quot;src/data/scala&amp;quot;),
                                     (baseDirectory.value / &amp;quot;src/web/scala&amp;quot;))

unmanagedResourceDirectories in Compile += baseDirectory.value / &amp;quot;src/data/resources&amp;quot;

unmanagedSourceDirectories in Test := Seq((baseDirectory.value / &amp;quot;src/core-test/scala&amp;quot;),
                                      (baseDirectory.value / &amp;quot;src/web-test/scala&amp;quot;))

webappSrc in webapp &amp;lt;&amp;lt;= (baseDirectory in Compile) map { _ / &amp;quot;src/web/webapp&amp;quot; }

webappDest in webapp &amp;lt;&amp;lt;= (baseDirectory in Compile) map { _ / &amp;quot;src/web/webapp&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last two lines &lt;em&gt;webappSrc&lt;/em&gt; and &lt;em&gt;webappDest&lt;/em&gt; were needed because I also use a class that starts &lt;a href=&#34;http://www.eclipse.org/jetty/&#34;&gt;Jetty&lt;/a&gt; by hand where I hook the Scalatra listener.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JettyLauncher.scala&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.eclipse.jetty.server.Server
import org.eclipse.jetty.servlet.DefaultServlet
import org.eclipse.jetty.webapp.WebAppContext
import org.scalatra.servlet.ScalatraListener

object JettyLauncher {

    def main(args: Array[String]) {
        val port = if(System.getenv(&amp;quot;PORT&amp;quot;) != null) System.getenv(&amp;quot;PORT&amp;quot;).toInt else 8089
    
        val server = new Server(port)
        val context = new WebAppContext()
        context.setClassLoader(JettyLauncher.getClass.getClassLoader)
        context setContextPath &amp;quot;/&amp;quot;
        context.setResourceBase(&amp;quot;src/web/webapp&amp;quot;)
        context.addEventListener(new ScalatraListener)
        context.addServlet(classOf[DefaultServlet], &amp;quot;/&amp;quot;)
    
        server.setHandler(context)
    
        server.start
        server.join
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When executing this class, the &lt;em&gt;ScalatraBootstrap&lt;/em&gt; could not be found and that&amp;rsquo;s why I had to add the following line to my &lt;em&gt;JettyLauncher&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; context.setClassLoader(JettyLauncher.getClass.getClassLoader)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scalatra relies on the default directory &lt;em&gt;main&lt;/em&gt; to find &lt;em&gt;ScalatraBootstrap&lt;/em&gt; and this is how I managed to make sure the &lt;em&gt;ScalatraBootstrap&lt;/em&gt; could be found.&lt;/p&gt;

&lt;p&gt;Note that I also had to change the resource base, pointing to the &lt;em&gt;web&lt;/em&gt; folder instead of &lt;em&gt;main&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; context.setResourceBase(&amp;quot;src/web/webapp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As I use &lt;a href=&#34;http://scalate.github.io/scalate/documentation/jade.html&#34;&gt;Jade&lt;/a&gt; templates via &lt;a href=&#34;http://scalate.github.io/scalate/&#34;&gt;Scalate&lt;/a&gt;, I had to change the Scalate template configuration on &lt;strong&gt;build.scala&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build.scala&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;object MonitorBuild extends Build {
    val Organization = &amp;quot;com.codurance&amp;quot;
    val Name = &amp;quot;monitor&amp;quot;
    val Version = &amp;quot;0.1.0-SNAPSHOT&amp;quot;
    val ScalaVersion = &amp;quot;2.11.6&amp;quot;
    val ScalatraVersion = &amp;quot;2.4.0.RC1&amp;quot;
    
    lazy val project = Project(
        &amp;quot;monitor&amp;quot;,
        file(&amp;quot;.&amp;quot;),
        settings = ScalatraPlugin.scalatraSettings ++ scalateSettings ++ Seq(
    
            // dependencies and some other stuff here
    
            scalateTemplateConfig in Compile &amp;lt;&amp;lt;= (sourceDirectory in Compile) { base =&amp;gt;
                Seq(
                    TemplateConfig(
                        new RichFile(new File(&amp;quot;src&amp;quot;)) / &amp;quot;web&amp;quot; / &amp;quot;webapp&amp;quot; / &amp;quot;WEB-INF&amp;quot; / &amp;quot;templates&amp;quot;,
                        Seq.empty, 
                        Seq(
                            Binding(&amp;quot;context&amp;quot;, &amp;quot;_root_.org.scalatra.scalate.ScalatraRenderContext&amp;quot;, importMembers = true, isImplicit = true)
                        ), 
                        Some(&amp;quot;templates&amp;quot;)
                    )
                )
            }
        )
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important line above is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; new RichFile(new File(&amp;quot;src&amp;quot;)) / &amp;quot;web&amp;quot; / &amp;quot;webapp&amp;quot; / &amp;quot;WEB-INF&amp;quot; / &amp;quot;templates&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes Scalate find the templates in the &lt;em&gt;web&lt;/em&gt; directory instead of &lt;em&gt;main&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Make sure you have these lines in the &lt;strong&gt;plugins.sbt&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;gt; addSbtPlugin(&amp;quot;com.mojolly.scalate&amp;quot; % &amp;quot;xsbt-scalate-generator&amp;quot; % &amp;quot;0.5.0&amp;quot;)
&amp;gt;
&amp;gt; addSbtPlugin(&amp;quot;org.scalatra.sbt&amp;quot; % &amp;quot;scalatra-sbt&amp;quot; % &amp;quot;0.4.0&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I didn&amp;rsquo;t need to change anything on my &lt;strong&gt;web.xml&lt;/strong&gt; and &lt;strong&gt;ScalatraBootstrap&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The configuration described above allows me to run the application via&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; ./sbt container:start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that is how I normally run the application locally and also allows me to create a fat jar file and execute the &lt;em&gt;JettyLauncher&lt;/em&gt; class that is how I run in production:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; java -cp &amp;lt;myapplication&amp;gt;.jar com.codurance.JettyLauncher
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fat jar file is created via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; ./sbt assembly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the collapsed directory structure looks on &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;IntelliJ IDEA&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;
&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-11-21-folder-structure-collapsed.jpg&#34;  class=&#34;img img-responsive style-screengrab&#34; style=&#34;max-height: 98px;&#34;/&gt;

and this is how it looks when expanded:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-11-21-folder-structure-expanded.jpg&#34;  class=&#34;img img-responsive style-screengrab&#34; style=&#34;max-height: 500px;&#34;/&gt;


&lt;p&gt;Although it took me a while to figure all this out, I&amp;rsquo;m happy to be able to structure my project the way it makes sense to us.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google&#43; Sign-In with Scalatra</title>
      <link>http://codurance.com/blog/google-plus-sign-in-with-scalatra/</link>
      <pubDate>Thu, 10 Jul 2014 15:35:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/google-plus-sign-in-with-scalatra/</guid>
      <description>

&lt;h3 id=&#34;the-requirements&#34;&gt;The requirements&lt;/h3&gt;

&lt;p&gt;For one of our internal pet-projects at Codurance, we decided to have authentication and authorisation using &lt;a href=&#34;https://developers.google.com/+/&#34;&gt;Google+ Sign-in&lt;/a&gt;. Google+ Sign-In is able to authenticate anyone with a Google email account (gmail or business) using OAuth 2.0. However, we wanted to restrict the application to Codurance craftsmen only, that means, people with a Codurance email address.&lt;/p&gt;

&lt;p&gt;The application had also to redirect us to the desired URL, in case we tried to access a deep URL without being authenticated.&lt;/p&gt;

&lt;h3 id=&#34;technology-stack&#34;&gt;Technology stack&lt;/h3&gt;

&lt;p&gt;In this project we are using:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scalatra.org/&#34;&gt;Scalatra&lt;/a&gt; as a web micro-framework&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jade-lang.com/&#34;&gt;Jade&lt;/a&gt; as template engine&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-sbt.org/&#34;&gt;sbt&lt;/a&gt; as our build tool.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/json4s/json4s&#34;&gt;json4s&lt;/a&gt; for JSON manipulation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stackmob/newman&#34;&gt;Newman&lt;/a&gt; as HTTP client library&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;h4 id=&#34;authentication-filter&#34;&gt;Authentication Filter&lt;/h4&gt;

&lt;p&gt;First we need to add an AuthenticationFilter to our Scalatra application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.servlet.ServletContext

import com.codurance.cerebro.controllers.MainController
import com.codurance.cerebro.security.AuthenticationFilter
import org.scalatra._

class ScalatraBootstrap extends LifeCycle {
    override def init(context: ServletContext) {
        context.mount(new AuthenticationFilter, &amp;quot;/*&amp;quot;)
        context.mount(new MainController, &amp;quot;/*&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the AuthenticationFilter, we need to redirect to the sign-in page when we don&amp;rsquo;t have a user in the session. We also need to exclude the pages and URLs that don&amp;rsquo;t need a user to be logged in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.codurance.cerebro.security

import org.scalatra.ScalatraFilter

class AuthenticationFilter extends ScalatraFilter {
    before() {
        if (isProtectedUrl &amp;amp;&amp;amp; userIsNotAuthenticated) {
            redirect(&amp;quot;/signin?originalUri=&amp;quot; + originalURL)
        }
    }

    def originalURL(): String = {
        val url = Option(request.getRequestURI).getOrElse(&amp;quot;/main&amp;quot;)
        if (url.startsWith(&amp;quot;/signin&amp;quot;)) &amp;quot;/main&amp;quot; else url
    }

    def userIsNotAuthenticated: Boolean = {
        request.getSession.getAttribute(&amp;quot;user&amp;quot;) == null
    }

    def isProtectedUrl(): Boolean = {
        val url = request.getRequestURI();
        !(url.equals(&amp;quot;/signin&amp;quot;) || url.equals(&amp;quot;/authorise&amp;quot;) || url.equals(&amp;quot;/not-authorised&amp;quot;))
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about filters, check the &lt;a href=&#34;http://www.scalatra.org/&#34;&gt;Scalatra&lt;/a&gt; documentation.&lt;/p&gt;

&lt;h4 id=&#34;signin-jade&#34;&gt;signin.jade&lt;/h4&gt;

&lt;p&gt;Then we need a sign-in page, that is displayed when the user is not authenticated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;- attributes(&amp;quot;title&amp;quot;) = &amp;quot;Cerebro&amp;quot;
- attributes(&amp;quot;layout&amp;quot;) = &amp;quot;/WEB-INF/templates/layouts/no-header.jade&amp;quot;

-@ val originalUri: String

h1 Welcome to Cerebro!

p= &amp;quot;Please sigin in using google id!&amp;quot;
p URI: #{originalUri}

:!javascript
    function onSignInCallback(authResult) {
        if (authResult[&#39;access_token&#39;]) {
            $.ajax({
                type: &#39;POST&#39;,
                url: &#39;/authorise&#39;,
                contentType: &#39;application/x-www-form-urlencoded; charset=utf-8&#39;,
                data: {authCode: authResult.code },
                success: function(result) {
                    window.location.replace(&#39;#{originalUri}&#39;);
                },
                error: function(result) {
                    window.location.replace(&#39;/not-authorised&#39;);
                }
            });
        }
    }

#gConnect
    button(class=&#39;g-signin&#39;
    data-scope=&#39;https://www.googleapis.com/auth/plus.login https://www.googleapis.com/auth/userinfo.email&#39;
    data-requestvisibleactions=&#39;http://schemas.google.com/AddActivity&#39;
    data-clientId=&#39;&amp;lt;&amp;lt;YOUR_CLIENT_ID&amp;gt;&amp;gt;&#39;
    data-accesstype=&#39;offline&#39; data-callback=&#39;onSignInCallback&#39;
    data-theme=&#39;dark&#39;
    data-cookiepolicy=&#39;single_host_origin&#39;)

script(src=&#39;https://plus.google.com/js/client:plusone.js&#39;)
script(src=&#39;//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are not using Jade or want more details, check the &lt;a href=&#34;https://developers.google.com/+/web/signin/add-button&#34;&gt;official documentation&lt;/a&gt; about how to &lt;a href=&#34;https://developers.google.com/+/web/signin/add-button&#34;&gt;add the sign-in button&lt;/a&gt; to your page.&lt;/p&gt;

&lt;p&gt;This should be enough to trigger the Google authentication form when clicking on the Sign-In button. Once the authentication is done, the callback function will send us a POST with the &amp;ldquo;authCode&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;main-controller&#34;&gt;Main Controller&lt;/h4&gt;

&lt;p&gt;We then need a controller that will respond to all these requests, displays the respective pages, and do the authorisation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.codurance.cerebro.controllers

import javax.servlet.http.{HttpServletResponse, HttpServletRequest}

class BaseController extends CerebroStack {

    def display(page: String, attributes: (String, Any)*)(implicit request: HttpServletRequest, response: HttpServletResponse): String = {
        contentType = &amp;quot;text/html&amp;quot;
        val all_attributes = attributes :+ (&amp;quot;user&amp;quot;, session.getAttribute(&amp;quot;user&amp;quot;))
        jade(page, all_attributes: _*)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.codurance.cerebro.controllers

import com.codurance.cerebro.security.CoduranceAuthorisation.authorise

import scala.Predef._

class MainController extends BaseController {

    get(&amp;quot;/&amp;quot;) {
        display(&amp;quot;main&amp;quot;)
    }

    get(&amp;quot;/main&amp;quot;) {
        display(&amp;quot;main&amp;quot;)
    }

    get(&amp;quot;/signin&amp;quot;) {
        display(&amp;quot;signin&amp;quot;, &amp;quot;originalUri&amp;quot; -&amp;gt; request.getParameter(&amp;quot;originalUri&amp;quot;))
    }

    get(&amp;quot;/not-authorised&amp;quot;) {
        display(&amp;quot;not-authorised&amp;quot;)
    }

    post(&amp;quot;/authorise&amp;quot;) {
        val authCode: String = params.getOrElse(&amp;quot;authCode&amp;quot;, halt(400))
        authorise(authCode)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The MainController responds to &amp;ldquo;/authorise&amp;rdquo;, which invokes the authorisation function defined inside CoduranceAuthorisation. Note that we receive the &amp;ldquo;authCode&amp;rdquo; from the Google+ authentication. Once the user was authenticated, we had to make the application available just for users using a Codurance email. For that, we had to invoke the &lt;a href=&#34;https://developers.google.com/+/api/latest/people&#34;&gt;Google+ People API&lt;/a&gt; to get more information (email address, domain, etc).&lt;/p&gt;

&lt;p&gt;The authorise function would then check if the user belongs to the Codurance domain and add her to the session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.codurance.cerebro.security

import java.net.URL
import javax.servlet.http.{HttpSession, HttpServletResponse, HttpServletRequest}
import javax.servlet.http.HttpServletResponse._

import com.google.api.client.googleapis.auth.oauth2.{GoogleAuthorizationCodeTokenRequest, GoogleTokenResponse}
import com.google.api.client.http.javanet.NetHttpTransport
import com.google.api.client.json.jackson.JacksonFactory
import com.stackmob.newman._
import com.stackmob.newman.dsl._

import scala.concurrent.Await
import scala.concurrent.duration._

object CoduranceAuthorisation {

    implicit val httpClient = new ApacheHttpClient

    val GOOGLE_PLUS_PEOPLE_URL = &amp;quot;https://www.googleapis.com/plus/v1/people/me?fields=aboutMe%2Ccover%2FcoverPhoto%2CdisplayName%2Cdomain%2Cemails%2Clanguage%2Cname&amp;amp;access_token=&amp;quot;
    val CLIENT_ID: String = &amp;quot;&amp;lt;&amp;lt;YOUR_CLIENT_ID&amp;gt;&amp;gt;&amp;quot;
    val CLIENT_SECRET = &amp;quot;&amp;lt;&amp;lt;YOUR_CLIENT_SECRET&amp;gt;&amp;gt;&amp;quot;
    val API_KEY = &amp;quot;&amp;lt;&amp;lt;YOUR_API_KEY&amp;gt;&amp;gt;&amp;quot;
    val APPLICATION_NAME = &amp;quot;&amp;lt;&amp;lt;YOUR_APP_NAME&amp;gt;&amp;gt;&amp;quot;
    val JSON_FACTORY = new JacksonFactory()
    val TRANSPORT = new NetHttpTransport()

    def authorise(authCode: String)(implicit session: HttpSession, response: HttpServletResponse): Unit = {
        val user = userFor(authCode)
        user.domain match {
            case Some(Domain(&amp;quot;codurance.com&amp;quot;)) =&amp;gt; {
                session.setAttribute(&amp;quot;user&amp;quot;, user)
                response.setStatus(SC_OK)
            }
            case _ =&amp;gt; response.setStatus(SC_UNAUTHORIZED)
        }
    }

    def userFor(authCode: String): User = {
        val tokenResponse: GoogleTokenResponse =
            new GoogleAuthorizationCodeTokenRequest(
                TRANSPORT, JSON_FACTORY, CLIENT_ID, CLIENT_SECRET, authCode, &amp;quot;postmessage&amp;quot;
            ).execute
        val url = new URL(GOOGLE_PLUS_PEOPLE_URL + tokenResponse.getAccessToken)
        val userInfo = Await.result(GET(url).apply, 10.seconds)
        GooglePlusJSONResponseParser.toUser(userInfo.bodyString, tokenResponse.toString)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that in the GOOGLE_PLUS_PEOPLE_URL we specify all the fields we are interested in, including the &lt;em&gt;domain&lt;/em&gt; and &lt;em&gt;emails&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GooglePlusJSONResponseParser&lt;/strong&gt; is a class that we created to parse the JSON response and convert into a User object. We are not showing it in order to keep this post short and focused. You can create your own JSON parser. :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; Don&amp;rsquo;t forget to import add the Google+ APIs to your sbt build file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    &amp;quot;com.google.apis&amp;quot; % &amp;quot;google-api-services-oauth2&amp;quot; % &amp;quot;v2-rev59-1.17.0-rc&amp;quot;,
    &amp;quot;com.google.apis&amp;quot; % &amp;quot;google-api-services-plus&amp;quot; % &amp;quot;v1-rev115-1.17.0-rc&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it. You now can display the name of the user on all your pages, using a default layout.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;-@ val title: String
-@ val headline: String = title
-@ val body: String
-@ val user: com.codurance.cerebro.security.User

!!!
html
    head
        title= title
    body
        header
            div
                span Hello #{user.name.displayName}
        div
            h1= headline
            != body
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>