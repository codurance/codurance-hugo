<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/cloud/</link>
    <description>Recent content in Cloud on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 30 Jun 2015 12:00:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/cloud/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Shape your infrastructure with Terraform</title>
      <link>http://codurance.com/blog/shape-your-infrastructure-with-terraform/</link>
      <pubDate>Tue, 30 Jun 2015 12:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/shape-your-infrastructure-with-terraform/</guid>
      <description>

&lt;p&gt;The popularity of cloud infrastructure services has hugely increased over the last few years. Companies value the flexibility and reliability provided by such services. The simplicity of the solutions delivered by cloud providers should remove the burden from the shoulders of busy Dev and Ops people and give the possibility to focus on real customer&amp;rsquo;s needs.&lt;/p&gt;

&lt;p&gt;Unfortunately the reality is not necessarily so simple. When you start your journey in the cloud you will discover new challenges. One of these challenges will be connected with the creation and provisioning of your new infrastructure. Simple structures can be created within minutes using web pages or a CLI, but these are not the best ways to create a cloud with 100 machines.&lt;/p&gt;

&lt;p&gt;AWS provides many different interfaces which allow automation of an infrastructure process. You can use a REST API or CLI to create your own script. This is probably the most flexible solution, but at the same time it can be time consuming.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://terraform.io/&#34;&gt;Terraform&lt;/a&gt; from HashiCorp can give you similar flexibility and at the same time you don&amp;rsquo;t have to spend weeks to write bash or python scripts to provision your cloud.&lt;/p&gt;

&lt;h2 id=&#34;terraform-for-the-rescue-plan-apply-update-destroy&#34;&gt;Terraform for the rescue - plan, apply, update, destroy.&lt;/h2&gt;

&lt;h3 id=&#34;plan&#34;&gt;Plan&lt;/h3&gt;

&lt;h4 id=&#34;infrastructure-diagram&#34;&gt;Infrastructure diagram&lt;/h4&gt;

&lt;p&gt;
&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/terraform/ShapeYourInfrastructure_VPC.png&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;

To demonstrate the use of Terraform we need to introduce some example infrastructure: let&amp;rsquo;s provision a structure which will support a simple web service running in AWS. This web service will expose an API via a web proxy server. The service also requires a database and this database should have a separate EC2 instance to ease database maintenance. Instances responsible for business logic will be hidden in a private subnet and only the web proxy
server will be available to the wider internet. At the same time our service needs to connect to external resources - therefore a NAT instance will take the responsibility of managing network connections from within the private subnet. All of these resources will constitute a single &lt;a href=&#34;http://aws.amazon.com/vpc/&#34;&gt;Virtual Private Cloud&lt;/a&gt; (VPC).&lt;/p&gt;

&lt;h4 id=&#34;provider&#34;&gt;Provider&lt;/h4&gt;

&lt;p&gt;We are now ready to introduce Terraform. We need to create configuration files which will describe components required to build our infrastructure. Configuration files can be written in &lt;a href=&#34;https://terraform.io/docs/configuration/&#34;&gt;HashiCorp Configuration Language&lt;/a&gt; (similar to YAML) or JSON. All configuration files should have extension &lt;strong&gt;&lt;em&gt;.tf&lt;/em&gt;&lt;/strong&gt; and be stored in the same directory. Terraform automatically combines all resources defined in &lt;strong&gt;&lt;em&gt;.tf&lt;/em&gt;&lt;/strong&gt; files.&lt;/p&gt;

&lt;p&gt;Before we add any resource we have know where our resources are going to exist. To do that we have to create a &lt;em&gt;provider&lt;/em&gt; definition.&lt;/p&gt;

&lt;p&gt;Terraform&amp;rsquo;s provider is the mechanism used for managing resources, in our case we&amp;rsquo;ll use the AWS provider. Our first configuration file might look like this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;provider &amp;quot;aws&amp;quot; {
    access_key = &amp;quot;ACCESS_KEY_HERE&amp;quot;
    secret_key = &amp;quot;SECRET_KEY_HERE&amp;quot;
    region     = &amp;quot;eu-west-1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously we don&amp;rsquo;t want to keep our secrets in a file which will potentially be stored in version control.
We also want to have flexibility when we define a region in which we want to provision our environment. Terraform gives us the possibility to introduce variables.&lt;/p&gt;

&lt;p&gt;First we have to declare the variables we want to use (see &lt;strong&gt;&lt;em&gt;provider-variables.tf&lt;/em&gt;&lt;/strong&gt;). The variables declaration introduces names, structure and default values for all variables used in the configuration file. We will override these default values later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;provider&amp;quot; {
    default = {
        access_key = &amp;quot;not undefined yet&amp;quot;
        secret_key = &amp;quot;not undefined yet&amp;quot;
        region     = &amp;quot;not undefined yet&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can update &lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;provider &amp;quot;aws&amp;quot; {
    access_key = &amp;quot;${var.provider.access_key}&amp;quot;
    secret_key = &amp;quot;${var.provider.secret_key}&amp;quot;
    region     = &amp;quot;${var.provider.region}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vpc&#34;&gt;VPC&lt;/h4&gt;

&lt;p&gt;When we know how to connect to our provider we can introduce resources. A resource definition in Terraform contains information about the type of a resource and its name. Types of resources are predefined by Terraform and represent building elements which we can instantiate in the cloud. Each resource also has a predefined set of config properties which describe the resource in detail. For a full list of supported AWS resource types, see &lt;a href=&#34;https://www.terraform.io/docs/providers/aws/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Resource Syntax&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;lt;TYPE&amp;gt; &amp;lt;NAME&amp;gt; {
    &amp;lt;config_key&amp;gt; = &amp;lt;config_value&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our case we have to define a VPC for all our resources to reside in. We need to assign our VPC to a specific range of addresses by defining a &lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR&lt;/a&gt; block. Each VPC also needs an internet gateway.&lt;/p&gt;

&lt;p&gt;Once again instead of hardcoded values we will declare variables specific for our VPC definition.&lt;/p&gt;

&lt;p&gt;We can also introduce a variable which defines the name of our environment. This name will allow us to tag resources and recognise to which environment a given resource belongs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;environment-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;environment_name&amp;quot; {
    default = &amp;quot;unknown-environment&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;vpc-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_vpc&amp;quot; &amp;quot;environment&amp;quot; {
    cidr_block = &amp;quot;${var.vpc.cidr_block}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-vpc&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_internet_gateway&amp;quot; &amp;quot;environment&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-internet-gateway&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;vpc-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;vpc&amp;quot; {
    default = {
        owner_id = &amp;quot;unknown&amp;quot;
        cidr_block = &amp;quot;10.changeit.0.0/16&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the type of a resource and its name as a reference variable to access properties exposed by a given resource, as we did to reference the VPC id above. Some properties of a resource will be defined by Terraform during creation of the resource, like internal ids or names. Some are already defined in our scripts.&lt;/p&gt;

&lt;p&gt;In the above example we assign an internet gateway to our VPC by referencing the property *&lt;strong&gt;id&lt;/strong&gt; of &lt;strong&gt;&lt;em&gt;aws_vpc&lt;/em&gt;&lt;/strong&gt; resource with name &lt;strong&gt;&lt;em&gt;environment&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;subnets&#34;&gt;Subnets&lt;/h4&gt;

&lt;p&gt;Our example VPC should contain two subnets. For each subnet we have to define a range of addresses available (CIDR block), an availability zone and of course we have to assign this subnet to the VPC. Again, we declare variables instead defining values directly in the configuration script.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;subnets-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_subnet&amp;quot; &amp;quot;public-subnet&amp;quot; {
    vpc_id            = &amp;quot;${aws_vpc.environment.id}&amp;quot;
    cidr_block        = &amp;quot;${var.vpc_public_subnet.cidr_block}&amp;quot;
    availability_zone = &amp;quot;${var.vpc_public_subnet.availability_zone}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-public-subnet&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_subnet&amp;quot; &amp;quot;private-subnet&amp;quot; {
    vpc_id            = &amp;quot;${aws_vpc.environment.id}&amp;quot;
    cidr_block        = &amp;quot;${var.vpc_private_subnet.cidr_block}&amp;quot;
    availability_zone = &amp;quot;${var.vpc_private_subnet.availability_zone}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-private-subnet&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;subnets-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;vpc&amp;quot; {
    default = {
        owner_id = &amp;quot;unknown&amp;quot;
        cidr_block = &amp;quot;10.changeit.0.0/16&amp;quot;
    }
}

variable &amp;quot;vpc_public_subnet&amp;quot; {
    default = {
        cidr_block = &amp;quot;10.changeit.0.0/24&amp;quot;
        availability_zone = &amp;quot;changeit&amp;quot;
    }
}

variable &amp;quot;vpc_private_subnet&amp;quot; {
    default = {
        cidr_block = &amp;quot;10.changeit.1.0/24&amp;quot;
        availability_zone = &amp;quot;changeit&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;route-tables&#34;&gt;Route tables&lt;/h4&gt;

&lt;p&gt;Each subnet in a VPC must be associated with a route table. This time we have an unusual situation. We have the reference to a resource which was not defined yet (&lt;strong&gt;&lt;em&gt;${aws_instance.nat.id}&lt;/em&gt;&lt;/strong&gt;). The order of files is not important for Terraform. It combines all files and based on that knowledge prepares a plan of execution. For that reason we can refer to resources which are defined in different files. Terraform will produce an error during creation if the resource is not defined anywhere.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;route_tables-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_route_table&amp;quot; &amp;quot;public-subnet&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    route {
        cidr_block = &amp;quot;0.0.0.0/0&amp;quot;
        gateway_id = &amp;quot;${aws_internet_gateway.environment.id}&amp;quot;
    }

    tags {
        Name        = &amp;quot;${var.environment_name}-public-subnet-route-table&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_route_table_association&amp;quot; &amp;quot;public-subnet&amp;quot; {
    subnet_id      = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    route_table_id = &amp;quot;${aws_route_table.public-subnet.id}&amp;quot;
}

resource &amp;quot;aws_route_table&amp;quot; &amp;quot;private-subnet&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    route {
        cidr_block  = &amp;quot;0.0.0.0/0&amp;quot;
        instance_id = &amp;quot;${aws_instance.nat.id}&amp;quot;
    }

    tags {
        Name        = &amp;quot;${var.environment_name}-private-subnet-route-table&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_route_table_association&amp;quot; &amp;quot;private-subnet&amp;quot; {
    subnet_id      = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    route_table_id = &amp;quot;${aws_route_table.private-subnet.id}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;security-groups&#34;&gt;Security groups&lt;/h4&gt;

&lt;p&gt;A definition of any EC2 instance requires assigning it to a security group. Security groups are another type of resource in Terraform. Once again configuration of this resource type is straightforward. Depending on our needs we can define inbound (ingress) and outbound (egress) rules for the desired range of ports, protocols and addresses.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;security_groups-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_security_group&amp;quot; &amp;quot;nat&amp;quot; {
    name = &amp;quot;${var.environment_name}-nat&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    egress {
        from_port   = 80
        to_port     = 80
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-nat-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_security_group&amp;quot; &amp;quot;public&amp;quot; {
    name = &amp;quot;${var.environment_name}-public&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = &amp;quot;-1&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }

    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-public-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_security_group&amp;quot; &amp;quot;private&amp;quot; {
    name = &amp;quot;${var.environment_name}-private&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;${var.vpc_public_subnet.cidr_block}&amp;quot;]
    }
(...)
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = &amp;quot;-1&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }

    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-private-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ec2-instances&#34;&gt;EC2 Instances&lt;/h4&gt;

&lt;p&gt;With all the above resources declared we can finally define our EC2 instances.&lt;/p&gt;

&lt;p&gt;Our NAT instance and web proxy instance require an Elastic IP (resource &lt;strong&gt;&lt;em&gt;aws_eip&lt;/em&gt;&lt;/strong&gt;). We also need to choose an instance type for each EC2 instance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;instances-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_instance&amp;quot; &amp;quot;nat&amp;quot; {
    ami                         = &amp;quot;${var.nat.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.nat.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.nat.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.nat.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    associate_public_ip_address = true
    source_dest_check           = false

    tags {
        Name        = &amp;quot;${var.environment_name}-nat&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_eip&amp;quot; &amp;quot;nat&amp;quot; {
    instance = &amp;quot;${aws_instance.nat.id}&amp;quot;
    vpc      = true
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;web-proxy&amp;quot; {
    ami                         = &amp;quot;${var.web-proxy.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.web-proxy.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.web-proxy.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.public.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    associate_public_ip_address = true
    source_dest_check           = true

    tags {
        Name        = &amp;quot;${var.environment_name}-web-proxy&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_eip&amp;quot; &amp;quot;web-proxy&amp;quot; {
  instance = &amp;quot;${aws_instance.web-proxy.id}&amp;quot;
  vpc      = true
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;database&amp;quot; {
    ami                         = &amp;quot;${var.database.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.database.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.database.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.private.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    associate_public_ip_address = false
    source_dest_check           = true

    tags {
        Name        = &amp;quot;${var.environment_name}-database&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;service&amp;quot; {
    ami                         = &amp;quot;${var.services.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.services.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.services.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.private.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    associate_public_ip_address = false
    source_dest_check           = true
    count                       = 3

    tags {
        Name        = &amp;quot;${var.environment_name}-service-${count.index}&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;instances-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;nat&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-14913f63&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;web-proxy&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;database&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;services&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verify&#34;&gt;Verify&lt;/h4&gt;

&lt;p&gt;Our VPC definition is now ready. But how do we know that everything is ready for provisioning? We can verify our all hard work. All we have to do is ask Terraform to prepare a plan by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform plan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform will combine all available files and prepare an execution plan. This means that all definitions will be verified before you start provisioning your resources. The output from this command will also give us an overview of the kind of operations that will be performed during execution of the plan.&lt;/p&gt;

&lt;p&gt;We have to remember that the plan only represents a dry run. We don&amp;rsquo;t connect to AWS at this point and we will not find any errors which might occur in the cloud. For example a plan will not show any errors if you have already exceeded your limit of available EC2 instances.&lt;/p&gt;

&lt;h3 id=&#34;apply&#34;&gt;Apply&lt;/h3&gt;

&lt;p&gt;So far we used only default values to run our plan. It is not particularly useful when you want to create real environment.&lt;/p&gt;

&lt;p&gt;To apply our execution plan we have to prepare a file which will contain the definitions of our variables. We can override default definitions by creating a file with extension &lt;strong&gt;&lt;em&gt;.tfvariables&lt;/em&gt;&lt;/strong&gt;. This file has the format of a regular Java property file where each key is the path of a variable and each value is the value assigned to it. An example variable file for our first environment might look like this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;my_first_vpc_environment.tfvariables&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;environment_name = &amp;quot;my_first_vpc_environment&amp;quot;

provider.access_key = &amp;quot;[MY_REAL_SECRET]&amp;quot;
provider.secret_key = &amp;quot;[MY_REAL_SECRET]&amp;quot;
provider.region = &amp;quot;eu-west-1&amp;quot;

vpc.owner_id   = &amp;quot;[MY_OWNER_ID]&amp;quot;
vpc.cidr_block = &amp;quot;10.0.0.0/16&amp;quot;

vpc_public_subnet.cidr_block         = &amp;quot;10.0.0.0/24&amp;quot;
vpc_public_subnet.availability_zone  = &amp;quot;eu-west-1a&amp;quot;

vpc_private_subnet.cidr_block        = &amp;quot;10.0.1.0/24&amp;quot;
vpc_private_subnet.availability_zone = &amp;quot;eu-west-1a&amp;quot;

nat.key_name                = &amp;quot;my_first_vpc_environment&amp;quot;
nat.availability_zone       = &amp;quot;eu-west-1a&amp;quot;

web-proxy.key_name          = &amp;quot;my_first_vpc_environment&amp;quot;
web-proxy.availability_zone = &amp;quot;eu-west-1a&amp;quot;

database.key_name           = &amp;quot;my_first_vpc_environment&amp;quot;
database.availability_zone  = &amp;quot;eu-west-1a&amp;quot;

services.key_name           = &amp;quot;my_first_vpc_environment&amp;quot;
services.availability_zone  = &amp;quot;eu-west-1a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify the plan again and if we decide that we are ready we can apply it by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform will now connect to AWS and try to create all resources defined in Terraform scripts. The output of this command is a state file &lt;strong&gt;&lt;em&gt;terraform.tfstate&lt;/em&gt;&lt;/strong&gt; which contains all the information about the environment that we just provisioned. At the time of writing &lt;a href=&#34;https://www.terraform.io/docs/state/index.html&#34;&gt;the state file must be kept for future execution&lt;/a&gt; (e.g. in your version control system), because Terraform uses it to determine differences between cloud state and the current definition stored in your scripts.&lt;/p&gt;

&lt;h3 id=&#34;change&#34;&gt;Change&lt;/h3&gt;

&lt;p&gt;Sometimes we have to change our environment. It requires just a change in your definition config. Based on
the state of your existing environment and your updated configuration, Terraform is able to prepare a new plan and apply changes to your infrastructure.&lt;/p&gt;

&lt;p&gt;You can use the &lt;strong&gt;&lt;em&gt;plan&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; commands in the same way as for a new environment. This time Terraform compares the state stored in the state file generated on the initial run, and plans/applies any newly-introduced changes to the configuration.&lt;/p&gt;

&lt;h3 id=&#34;destroy&#34;&gt;Destroy&lt;/h3&gt;

&lt;p&gt;Everything has to come to an end, sometime. When the time comes we can execute this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform once again reuses our state file and will remove all resources defined there.&lt;/p&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;In this post we only scratched the surface of Terraform. The AWS provider is one of &lt;a href=&#34;https://www.terraform.io/docs/providers/index.html&#34;&gt;many providers available&lt;/a&gt;. Terraform allows us to combine different providers which give the possibility of provisioning environments across multiple cloud providers.&lt;/p&gt;

&lt;p&gt;It also has other basic features. For example &lt;a href=&#34;https://www.terraform.io/docs/configuration/outputs.html&#34;&gt;outputs&lt;/a&gt; give you the possibility to generate files based on any available variables and resource properties. You can use it to generate documentation, config files or just human readable text files.&lt;/p&gt;

&lt;p&gt;Now our infrastructure can be managed in code. We can check it into source control, raise pull requests in GitHub and provide living documentation for our environment topology. We can lay the foundation for our deployments and tools like Puppet, Chef and Docker.&lt;/p&gt;

&lt;p&gt;All code examples described here can be found &lt;a href=&#34;https://github.com/robertfirek/ShapeYourInfrastructure&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cloud Application Design Considerations</title>
      <link>http://codurance.com/blog/cloud-application-design-considerations/</link>
      <pubDate>Fri, 19 Jun 2015 18:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/cloud-application-design-considerations/</guid>
      <description>

&lt;p&gt;When designing applications for the cloud, irrespective of the chosen platform, I have often found it useful to consider four specific topics during my initial discussions; scalability, availability, manageability and feasibility.&lt;/p&gt;

&lt;p&gt;It is important to remember that the items presented under each topic within this article are not an exhaustive list and are aimed only at presenting a starting point for a series of long and detailed conversations with the stakeholders of your project, always the most important part of the design of any application. The aim of these conversations should be to produce an initial high-level design and architecture. This is achieved by considering these four key elements holistically within the domain of the customers project requirements, always remembering to consider the side-effects and trade-offs of any design decision (i.e. what we gain vs. what we lose, or what we make more difficult).&lt;/p&gt;

&lt;h2 id=&#34;scalability&#34;&gt;Scalability&lt;/h2&gt;

&lt;p&gt;Conversations about scalability should focus on any requirement to add additional capacity to the application and related services to handle increases in load and demand. It is particularly important to consider each application tier when designing for scalability, how they should scale individually and how we can avoid contention issues and bottlenecks. Key areas to consider include: &lt;/p&gt;

&lt;h3 id=&#34;capacity&#34;&gt;Capacity&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Will we need to scale individual application layers and, if so, how can we achieve this without affecting availability?&lt;/li&gt;
&lt;li&gt;How quickly will we need to scale individual services?&lt;/li&gt;
&lt;li&gt;How do we add additional capacity to the application or any part of it?&lt;/li&gt;
&lt;li&gt;Will the application need to run at scale 24x7, or can we scale-down outside business hours or at weekends for example?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;platform-data&#34;&gt;Platform / Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Can we work within the constraints of our chosen persistence services while working at scale (database size, transaction throughput, etc.)?&lt;/li&gt;
&lt;li&gt;How can we partition our data to aid scalability within persistence platform constraints (e.g. maximum database sizes, concurrent request limits, etc.)?&lt;/li&gt;
&lt;li&gt;How can we ensure we are making efficient and effective use of platform resources? As a rule of thumb, I generally tend towards a design based on many small instances, rather than fewer large ones.&lt;/li&gt;
&lt;li&gt;Can we collapse tiers to minimise internal network traffic and use of resources, whilst maintaining efficient scalability and future code maintainability?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;load&#34;&gt;Load&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How can we improve the design to avoid contention issues and bottlenecks? For example, can we use queues or a service bus between services in a co-operating producer, competing consumer pattern?&lt;/li&gt;
&lt;li&gt;Which operations could be handled asynchronously to help balance load at peak times?&lt;/li&gt;
&lt;li&gt;How could we use the platform features for rate-leveling (e.g. Azure Queues, Service Bus, etc.)?&lt;/li&gt;
&lt;li&gt;How could we use the platform features for load-balancing (e.g. Azure Traffic Manager, Load Balancer, etc.)? &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;availability&#34;&gt;Availability&lt;/h2&gt;

&lt;p&gt;Availability describes the ability of the solution to operate in a manner useful to the consumer in spite of transient and enduring faults in the application and underlying operating system, network and hardware dependencies. In reality, there is often some crossover between items useful for availability and scalability.
Conversations should cover at least the following items:&lt;/p&gt;

&lt;h3 id=&#34;uptime-guarantees&#34;&gt;Uptime Guarantees&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;What Service Level Agreements (SLA’s) are the products required to meet?&lt;/li&gt;
&lt;li&gt;Can these SLA’s be met? Do the different cloud services we are planning to use all conform to the levels required? Remember that &lt;a href=&#34;http://codurance.com/2015/05/19/working-with-slas/&#34;&gt;SLA’s are composite&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;replication-and-failover&#34;&gt;Replication and failover&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Which parts of the application are most at risk from failure?&lt;/li&gt;
&lt;li&gt;In which parts of the system would a failure have the most impact?&lt;/li&gt;
&lt;li&gt;Which parts of the application could benefit from redundancy and failover options?&lt;/li&gt;
&lt;li&gt;Will data replication services be required?&lt;/li&gt;
&lt;li&gt;Are we restricted to specific geopolitical areas? If so, are all the services we are planning to use available in those areas?&lt;/li&gt;
&lt;li&gt;How do we prevent corrupt data from being replicated?&lt;/li&gt;
&lt;li&gt;Will recovery from a failure put excess pressure on the system? Do we need to implement retry policies and/or a circuit-breaker?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;disaster-recovery&#34;&gt;Disaster recovery&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In the event of a catastrophic failure, how do we rebuild the system?&lt;/li&gt;
&lt;li&gt;How much data, if any, is it acceptable to lose in a disaster recovery scenario?&lt;/li&gt;
&lt;li&gt;How are we handling backups? Do we have a need for backups in addition to data-replication?&lt;/li&gt;
&lt;li&gt;How do we handle “in-flight” messages and queues in the event of a failure?&lt;/li&gt;
&lt;li&gt;Are we idempotent? Can we replay messages?&lt;/li&gt;
&lt;li&gt;Where are we storing our VM images? Do we have a backup?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;What are the acceptable levels of performance? How can we measure that? What happens if we drop below this level?&lt;/li&gt;
&lt;li&gt;Can we make any parts of the system asynchronous as an aid to performance?&lt;/li&gt;
&lt;li&gt;Which parts of the system are the mostly highly contended, and therefore more likely to cause performance issues?&lt;/li&gt;
&lt;li&gt;Are we likely to hit traffic spikes which may cause performance issues? Can we auto-scale or use queue-centric design to cover for this?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;security&#34;&gt;Security&lt;/h3&gt;

&lt;p&gt;This is clearly a huge topic in itself, but a few interesting items to explore which relate directly to cloud-computing include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is the local law and jurisdiction where data is held? Remember to include the countries where failover and metrics data are held too.&lt;/li&gt;
&lt;li&gt;Is there a requirement for federated security (e.g. ADFS with Azure Active Directory)?&lt;/li&gt;
&lt;li&gt;Is this to be a hybrid-cloud application? How are we securing the link between our corporate and cloud networks?&lt;/li&gt;
&lt;li&gt;How do we control access to the administration portal of the cloud provider?&lt;/li&gt;
&lt;li&gt;How do we restrict access to databases, etc. from other services (e.g. IP Address white-lists, etc.)?&lt;/li&gt;
&lt;li&gt;How do we handle regular password changes?&lt;/li&gt;
&lt;li&gt;How does service-decoupling and multi-tenancy affect security?&lt;/li&gt;
&lt;li&gt;How we will deal with operating system and vendor security patches and updates?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;manageability&#34;&gt;Manageability&lt;/h2&gt;

&lt;p&gt;This topic of conversation covers our ability to understand the health and performance of the live system and manage site operations. Some useful cloud specific considerations include:&lt;/p&gt;

&lt;h3 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How are we planning to monitor the application?&lt;/li&gt;
&lt;li&gt;Are we going to use off-the-shelf monitoring services or write our own?&lt;/li&gt;
&lt;li&gt;Where will the monitoring/metrics data be physically stored? Is this in line with data protection policies?&lt;/li&gt;
&lt;li&gt;How much data will our plans for monitoring produce?&lt;/li&gt;
&lt;li&gt;How will we access metrics data and logs? Do we have a plan to make this data useable as volumes increase?&lt;/li&gt;
&lt;li&gt;Is there a requirement for auditing as well as logging?&lt;/li&gt;
&lt;li&gt;Can we afford to lose some metrics/logging/audit data (i.e. can we use an asynchronous design to “fire and forget” to help aid performance)?&lt;/li&gt;
&lt;li&gt;Will we need to alter the level of monitoring at runtime?&lt;/li&gt;
&lt;li&gt;Do we need automated exception reporting?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How do we automate the deployment?&lt;/li&gt;
&lt;li&gt;How do we patch and/or redeploy without disrupting the live system? Can we still meet the SLA’s?&lt;/li&gt;
&lt;li&gt;How do we check that a deployment was successful?&lt;/li&gt;
&lt;li&gt;How do we roll-back an unsuccessful deployment?&lt;/li&gt;
&lt;li&gt;How many environments will we need (e.g. development, test, staging, production) and how will deploy to each of them?&lt;/li&gt;
&lt;li&gt;Will each environment need separate data storage?&lt;/li&gt;
&lt;li&gt;Will each environment need to be available 24x7?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;feasibility&#34;&gt;Feasibility&lt;/h2&gt;

&lt;p&gt;When discussing feasibility we consider the ability to deliver and maintain the system, within budgetary and time constraints. Items worth investigating include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can the SLA’s ever be met (i.e. is there a cloud service provider that can give the uptime guarantees that we need to provide to our customer)?&lt;/li&gt;
&lt;li&gt;Do we have the necessary skills and experience in-house to design and build cloud applications?&lt;/li&gt;
&lt;li&gt;Can we build the application to the design we have within budgetary constraints and a timeframe that makes sense to the business?&lt;/li&gt;
&lt;li&gt;How much will we need to spend on operational costs (cloud providers often have very complex pricing structures)?&lt;/li&gt;
&lt;li&gt;What can we sensibly reduce (scope, SLAs, resilience)?&lt;/li&gt;
&lt;li&gt;What trade-offs are we willing to accept?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The consideration of these four topics (availability, scalability, manageability and feasibility) will help you discover areas in your application that require some cloud-specific thought, specifically in the early stages of a project. The items listed under each are definitely not exhaustive, but should give you a good starting point for discussion.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>