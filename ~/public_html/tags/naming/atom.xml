<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Naming on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/naming/</link>
    <description>Recent content in Naming on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Sun, 29 Mar 2015 21:22:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/naming/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dangerous Words</title>
      <link>http://codurance.com/blog/dangerous-words/</link>
      <pubDate>Sun, 29 Mar 2015 21:22:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/dangerous-words/</guid>
      <description>

&lt;p&gt;Ludwig Wittgenstein was one the greatest philosophers of 20th century. His book Tractatus Logico-Philosophicus addresses the limits of language and its relationship with reality. A friend of mine, great polemicist, suggested me to read it some years ago to understand one of his favourites conversational &lt;em&gt;deux ex machina&lt;/em&gt;: &amp;ldquo;I can&amp;rsquo;t prove that, because of the inherent insufficiency of the language.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Needless to say, I didn&amp;rsquo;t understand most of Wittgenstein&amp;rsquo;s book, but I started to share the concern about the problems that ambiguous or unrigorous language generates. Whenever I heard or read some well crafted thought, I obsessively revisit those words to figure out why they are so effective communicating.&lt;/p&gt;

&lt;p&gt;Clean, simple and expressive code tries to defeat, as much as possible, the gap previously mentioned between language and reality. However, without getting into the nitty-gritty details of narrative and syntax, we, as software community, have failed creating proper words that are central for our profession.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t want to approach the etiology of some of those words, but just shed some light on what are the problems generated for those unaccurate words.&lt;/p&gt;

&lt;h2 id=&#34;unit-testing&#34;&gt;Unit testing&lt;/h2&gt;

&lt;p&gt;Testing is one of the fields with more candidates to The Razzie words awards. Integration, system, component, acceptance and, of course, unit. What do they mean really? No two snow crystals are alike, and no two programmers opinions about those words either. This &lt;a href=&#34;https://www.google.co.uk/search?q=testing+pyramid&amp;amp;espv=2&amp;amp;biw=1680&amp;amp;bih=951&amp;amp;source=lnms&amp;amp;tbm=isch&amp;amp;sa=X&amp;amp;ei=IpgMVduKIcLY7Aag64DQDQ&amp;amp;ved=0CAYQ_AUoAQ&#34;&gt;google search&lt;/a&gt; is disheartening.&lt;/p&gt;

&lt;p&gt;Unit is probably the worst, as it&amp;rsquo;s the most ambiguous and the most important for TDD practitioners. A unit could be defined as something with clear boundaries, integrated in a bigger system and providing a single function. Defining those terms in a concrete problem is really complicated and it depends heavily on the language and ecosystem that we&amp;rsquo;re using.&lt;/p&gt;

&lt;p&gt;I think that more concrete naming like object, module or method testing would be easier for newbies. Because, and this is something important to note for seniors, when we get used to words, they lose their original meaning and get impregnated with our experiences and bias. So, yes, we all know what unit testing means, but maybe nobody thinks on the same.&lt;/p&gt;

&lt;h2 id=&#34;extreme-programming&#34;&gt;Extreme programming&lt;/h2&gt;

&lt;p&gt;Last LSCC roundtable had some very interesting conversations. One of those was about extremes. Almost everybody agreed that extremes are generally bad, and the word &amp;ldquo;dogma&amp;rdquo; appears several times as a synonym of &amp;ldquo;extreme&amp;rdquo;. Ideas located at the limits of some spectrum are usually considered as extreme, but also ideas that refuse to change when confronted with reality.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think that XP is an eccentrity or some fundamentalist view of programming that refuses to evolve. I think that XP could be thought as radical or vanguardist, but that, at least in our zeitgeist, doesn&amp;rsquo;t have that pejorative connotation of extreme.&lt;/p&gt;

&lt;p&gt;To be honest, the first time that I heard the phrase &amp;ldquo;Extreme Programming&amp;rdquo;, I thought that it was some weirdness related to the no-rules-super-hacker mindset.&lt;/p&gt;

&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;

&lt;p&gt;Whoever that has worked with old style Spring-Hibernate webapp will recognize the following flow: Controller -&amp;gt; Service -&amp;gt; DAO. What does that Service layer usually do? Holding the whole business logic of our app in a non-OOP fashion. What does service mean? &amp;ldquo;The action of helping or doing work for someone&amp;rdquo;. Every class or method that we write does work for someone else, so what is the point of calling a class WhateverService?&lt;/p&gt;

&lt;p&gt;To make things worse, there are application and domain services in DDD, and we have SOA (Service oriented architecture) and its younger cousin Microservices. Everything seems to be a service in software. Often I prefer to use words like API, server, backend, just to avoid that overloaded term.&lt;/p&gt;

&lt;h2 id=&#34;in-conclusion&#34;&gt;In Conclusion&lt;/h2&gt;

&lt;p&gt;As conclusion this post is not a complain to whoever created or made popular those terms. In fact, I think that people like Martin Fowler, Kent Beck or Uncle Bob have made a great work coining catchy acronyms or locutions. It&amp;rsquo;s just a call to attention to be aware of the dangers of ambiguous words.&lt;/p&gt;

&lt;p&gt;In some episode of House of Cards, one politician discuss thoroughly with his team about using &amp;ldquo;action&amp;rdquo; or &amp;ldquo;vision&amp;rdquo; as key words in a debate. We should have that mindset too, but with pragmatism, of course. That&amp;rsquo;s why I think that is a great idea to create some kind of agreed glossary whenever a new team is created.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Thanks to Samir for the edits.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Naming Test Classes and Methods</title>
      <link>http://codurance.com/blog/naming-test-classes-and-methods/</link>
      <pubDate>Sat, 13 Dec 2014 00:27:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/naming-test-classes-and-methods/</guid>
      <description>

&lt;p&gt;What should my first test be? What should I test next? These are common questions that I&amp;rsquo;m asked over and over again. I quite often ask these questions myself. Deciding on what to test is hard. Deciding on the order that things should be tested is even harder.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; But writing tests first is not the only problem. How often did we get frustrated while dealing with existing tests which we had no idea what they are testing?&lt;/p&gt;

&lt;p&gt;Over the years I met and paired with a lot of experienced TDD practicioners and each one of them have a slightly different way to decide which tests to write and in which order. They also have different approaches to actually write their tests. Some write the name of the test method first. Others don&amp;rsquo;t bother with the name of the test method; they only appropriately name it after they write the test code. Some prefer a more exploratory approach, making a mess at the beginning, and only refactor when they have a better understanding of the problem and enough code in front of them. Others prefer a more structured approach, doing a little bit more thinking and &amp;ldquo;just-in-time design&amp;rdquo; before they write their tests. Some start typing straight away and wait to see what the code will look like before making any naming and design assumptions. Some use a more &lt;em&gt;classicist&lt;/em&gt; approach by default. Others prefer a more &lt;em&gt;mockist outside-in&lt;/em&gt; approach. And to make things more confusing, experienced TDD practicioners mix-and-match styles and approaches according to what they are trying to test.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;ll try to describe how I generally think about my tests. Due to the nature of the projects I&amp;rsquo;m noramlly involved with&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; I tend to think and design (in my head) a little bit more before I start typing. Outside-In TDD is normally my default mode when writing tests. My main focus when writing tests is to clearly express the behaviour I want the application (or class) to have.&lt;/p&gt;

&lt;p&gt;This is the template I normally use to help me decide what to test and how to name my test methods according to the expected behaviour:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2014_12_12/class_and_method_name_template.jpg&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;This approach forces me to think about the behaviour I want my class to have, making it easier to write my first and subsequent tests. Even at a unit test level, I try my best to name my test methods in a way that a business person could understand, rarely using any technical language. Here are a few examples:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2014_12_12/class_methods_example.jpg&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Trying to form a sentence combining the name of the test class and the name of the test method forces me to really focus on the behaviour I want to test. Once I figure that out, it becomes quite easy to write my assertion since I just need to translate English to the programming language I&amp;rsquo;m using.&lt;/p&gt;

&lt;p&gt;One thing to notice is that I normally split the body of my tests into 3 blocks (given, when, then). However, in some tests I call the method under test from the assertion and some tests don&amp;rsquo;t need any setup. Many tests are quite simple and have only one line.&lt;/p&gt;

&lt;p&gt;And here are the 5 steps I normally follow when creating a new test class:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2014_12_12/test_in_5_steps.jpg&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;For subsequent test methods I iterate through steps 2 to 5. The skeleton of the production code is generated from the test class.&lt;/p&gt;

&lt;h4 id=&#34;why-do-i-use-should&#34;&gt;Why do I use &amp;ldquo;should&amp;rdquo;?&lt;/h4&gt;

&lt;p&gt;Many developers don&amp;rsquo;t like the use of the word &amp;ldquo;should&amp;rdquo;. Some say that it is redundant and should not be used. Others say that it is not strong enough. &amp;ldquo;Must&amp;rdquo; is too strong. What about &amp;ldquo;have to&amp;rdquo;? I&amp;rsquo;m still not sure about it. For now, I&amp;rsquo;ll stick with &amp;ldquo;should&amp;rdquo; but I may give &amp;ldquo;have to&amp;rdquo; a try. Since I only use it on the class name, I don&amp;rsquo;t really think it is a big deal and it helps me to construct a phrase when combining with the name of the test methods.&lt;/p&gt;

&lt;h3 id=&#34;bad-names&#34;&gt;Bad names&lt;/h3&gt;

&lt;p&gt;Here are some common names I&amp;rsquo;ve seen given to the variable that points to the class under test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BankAccount testee = new BankAccount();
BankAccount sut = new BankAccount();
BankAccount ba = new BankAccount();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** If it is a bank account, name the variable bankAccount.**&lt;/p&gt;

&lt;p&gt;And for methods, here are some&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;test_deposit_works() {…}             // what does &#39;works&#39; mean?
test_deposit_works_correctly() {…}   // should it ever work incorrectly?
test_deposit() {…}                   // what exactly is it testing?
check_balance_after_deposit() {…}    // what is it checking? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A test name should clearly indicate why a test should pass or fail, that means, I should not need to look at the assertion(s) to figure out what the test is actually testing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[BankAccountShould] have_balance_increased_after_a_deposit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the test above fails I&amp;rsquo;ll have a fairly good idea why it failed.&lt;/p&gt;

&lt;h3 id=&#34;considerations&#34;&gt;Considerations&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t really follow rules and quite often I do things in a different way. It all depends on what I&amp;rsquo;m doing and the context I&amp;rsquo;m in. Some projects already have a standard way of writing unit tests and if I&amp;rsquo;m a new joiner, I&amp;rsquo;ll comply to it. Having a standard is a good thing. It avoids confusion and (bad) surprises, regardless if the &amp;ldquo;standard&amp;rdquo; is good or not. What I described above is how I normally name and think about my tests, and it is the standard I often put in place when I start a new project. This is also how I&amp;rsquo;m teaching our apprentices at Codurance.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Ideally we would choose a sequence of small steps (tests) that could help us to gradually add functionality to our system and evolve our design.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Most of my work is done on bespoke business applications with a complex domain. I also normally work in projects where we constantly interact with product owners and business experts. All projects that I get involved are run using Agile methodologies. The approach I described works well for me because I normally write code according to well-defined user stories and acceptance criteria, which gives me a fairly good idea of what needs to be done before I start coding. It may not work so well if you do more exploratory work. I normally flip to a more &lt;em&gt;classicist&lt;/em&gt; approach when I&amp;rsquo;m exploring.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>