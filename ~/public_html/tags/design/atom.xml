<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/design/</link>
    <description>Recent content in Design on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 12 Apr 2016 00:24:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/design/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>We did it wrong, but not all was in vain</title>
      <link>http://codurance.com/blog/we-did-it-wrong-but-not-in-vain/</link>
      <pubDate>Tue, 12 Apr 2016 00:24:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/we-did-it-wrong-but-not-in-vain/</guid>
      <description>&lt;p&gt;Yes, there was over engineering. Loads of it. Back in the mid 90s, when I started my career as a developer, the goal was to become an architect. No serious developer would dare writing a single line of code before selecting our preferred design patterns—we would then decide how the business requirements would fit into them. Yes, we would first come up with our architecture, then our macro design (layers) and domain model (including UML diagrams), and then we would think about the business requirements and detailed use cases. Yes, user stories were not really a thing back then. We had long use cases with a basic flow and many alternative flows.&lt;/p&gt;

&lt;p&gt;The 90s were an interesting period to be a developer. We finally had the Internet and a few academic papers on structured design from 70s and 80s became available to us. We also had a few books focusing on Object-Oriented Programming, still a novelty in many places.&lt;/p&gt;

&lt;p&gt;I still remember the countless months we spent drawing class, sequence, component, deployment, and many other diagrams, trying to come up with the best design for the software that one day we would build. We built some prototypes as well, so I can’t say we were not coding or experimenting during the &lt;em&gt;elaboration phase&lt;/em&gt;. All the learnings from the prototypes would be fed back into our diagrams, of course.&lt;/p&gt;

&lt;p&gt;Besides the internal design, in the 90s we had an explosion of distributed systems as well. We had CORBA and DCOM. We had client/server and multi-tier architecture. We learnt about single point of failure when using databases as a communication point between applications. Yes, we had nasty problems with that. We learnt how to create “services”—SOA was emerging as an architectural concept. We learnt how to think about scalability and security. Many projects outside governments and banks were also becoming very large and complex.&lt;/p&gt;

&lt;p&gt;Creating a great design was the goal for most passionate software developers; it was also the path to become an architect and career evolution. We had to study and be good at software design. We had to understand in depth principles of structured and object-oriented design. We had to understand principles of distributed system. We had to understand in depth all levels of cohesion and coupling. We had to understand covariance and contravariance. We had to learn how to design components boundaries including their contracts and invariant. We had to learn to how to understand verbs and nouns, the language of the business, and map them into software. We would never pass a job interview without knowing how to model data in our relational databases, and mostly important, how to make our queries perform well. We had to define our proprietary protocols in the right granularity in order to make it easier for other systems to consume them and at the same time address I/O and bandwidth concerns. Yes, we spent a lot of time doing that.&lt;/p&gt;

&lt;p&gt;Software development in the 90s was all about design and architecture. And yes, it had to be done with UML.&lt;/p&gt;

&lt;p&gt;But although we learnt how to design, we failed in many other aspects. We didn’t deliver fast enough. In fact, in some projects we didn’t deliver anything at all. Most of the times, all the thinking we did trying to create a perfect design was completely wasted due to lack of quick feedback and our inability to cope with rapid business evolution. I still remember the huge spreadsheets we used to control change requests even before we had any code written. Yes, we screwed up big time. Many times.&lt;/p&gt;

&lt;p&gt;Fast-forwarding 20 years, some of us understood what we were doing was wrong. We then incorporated Agile, Lean, and many other principles and practices into the way we work. We incorporated many new design and architecture techniques into our tool kit. We incorporated new technologies. We incorporated different ways to collaborate with the business and also how to structure our teams. We learned that although design was important, nothing was more important than continuously delivering software. We learnt how to get feedback and iterate. We learnt we were responsible to test our own code. We learnt we had to support our software in production. We learnt the value of creating prototypes and throwing them away. We learnt the value of experimentation. But we also learnt we didn’t need to throw away all the design skills we acquired over the years in order to work in a better way. We didn’t need to discard all the great work done before and during our time, mainly around software design during the 70s, 80s and 90s. But the most important lesson we learnt was that context is king and that software design is all about trade offs. Design is pointless without delivery. But can we keep delivering code without a solid design foundation? I don’t think so.&lt;/p&gt;

&lt;p&gt;One of the biggest problems I see today in software design is binary thinking. If X is bad, than Y must be good. If X worked for company A, than it will also work for us. If a well-known person said something in a 45-minute talk in a conference or we found something written in a blog, it must be true. Always.&lt;/p&gt;

&lt;p&gt;Another common mistake caused by binary thinking is the belief that all features in a software project have the same degree of complexity and a single design choice will fit them all. But the truth is, some features are quite simple, others very complex, and many others are somewhere in between. Sometimes the complexity is found in the implementation; other times it is found on understanding and modelling the domain. Sometimes the complexity is in understanding what we should be building. Other times the complexity is in the integration with other systems. Parts of the same feature can also vary a lot in complexity: some parts may be trivial and quickly implemented while others can be extremely complex and demand a lot thinking up front. Some features are shallow (very few lines of code) while others are deep (thousands of lines of code spread through different modules). Non-functional requirements can also make the implementation of simple features (business-wise) very complex. And the interesting thing is that all of that can be found within the same software project. So, if we agree that different features in a software project have different degrees of complexity and size, there is no way we can apply binary thinking into software design—no single design approach will ever work in a reasonably complex software project.&lt;/p&gt;

&lt;p&gt;We live in a world where information is easily and quickly accessible. One search on Google and we can find many ready-made solutions to our problems. My fear is that, as an industry, we are losing the ability to think. We are losing the ability to research and make our own choices. More and more we are looking for a ready-made recipe. A shortcut. I call them a “Stack Overflow solution.”&lt;/p&gt;

&lt;p&gt;It makes me sad that, to some people, software design is synonymous of over-engineering. It also makes me sad to see that &amp;ldquo;no design at all” is becoming synonymous of Agile, Lean Startup, and fast delivery. I don’t think the originators and main proponents of good software design, Agile, and Lean principles ever meant that. Over-engineering is bad, but so is no design at all. Simple doesn’t mean crap. Simple means just enough design for what we know today, but not less. Paraphrasing Einstein, software design should be made as simple as possible, but not simpler. Or another way of putting it: code must be well-designed but not over-designed.&lt;/p&gt;

&lt;p&gt;After interviewing a lot of developers and reviewing a lot of code in the past few years, my main concern is that we are developing a hacker culture. Many developers I met who have been in the industry for less than a decade, have very little knowledge of good software design. They will claim otherwise, of course. If you think I’m exaggerating, ask developers in your team to explain cohesion and its different levels. Ask them about connascence, covariance and contravariance. Ask them about different degrees and types of coupling. Ask them about design by contract and invariant. For those that have heard about SOLID principles ask them where the SOLID principles came from. Many developers today say design patterns are bad. Ask them to describe some patterns, their differences, and when they should or should not be applied. Ask them about the different pattern classifications. Ask them about the difference between a Bridge, Adapter, and Mediator. What problem a Visitor is supposed to solve? Ask them what is a Memento? If they can’t explain that, how can they say patterns are bad?&lt;/p&gt;

&lt;p&gt;Many developers today are not aware of the software design foundation laid during the 70s, 80s, and 90s. Others prefer to ignore it: &lt;em&gt;That is over-engineering and they don’t need that.&lt;/em&gt; That’s fine, I can respect that. But why do we still have software that sucks then? Is the software being produced today really better than the software being produced 20 years ago? Why developers still struggle to design code with TDD? Why are we still talking about legacy code? For me, legacy code is synonymous of code that is badly designed, hence difficult to test and maintain.&lt;/p&gt;

&lt;p&gt;By no means I’m defending over-engineering or wasting time drawing diagrams in UML. What I’m trying to say is that at the same time I would never spend hours to design classes inside my core domain up front, I would also not try to build an enterprise application, one test at a time, without thinking about its overall design before start coding. Design is essential for software development. If I’m building an application that will live in an ecosystem alongside many applications, or with heavy non-functional requirements, or that needs to comply to regulations, yes, of course I would put a lot of thought about its overall structure (macro-design) before I start coding but I would still develop its features (“micro-level”) one test at a time. Design happens at all levels: from up-front at the architectural level to just-in-time at micro level as part of my TDD flow. Decide how much to design is a skill—it&amp;rsquo;s all about finding the &lt;a href=&#34;http://codurance.com/2015/06/17/inflection-point/&#34;&gt;inflection point&lt;/a&gt;, subject I covered on a &lt;a href=&#34;http://codurance.com/2015/06/17/inflection-point/&#34;&gt;previous blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Software design is one of the most important skills in software development. Good design enables developers to collaborate, business features to be added and changed frequently, and reliable test automation to be done. With experience, we learn how to quickly identify problems and decide the amount of time we should spend on it. We also learn that most design decisions should be made in the last responsible moment, that means, we try not to commit to a design too early, while we don’t know enough about the problem.&lt;/p&gt;

&lt;p&gt;And that’s why I say that not everything we did in the 90s was in vain. Although we over-engineered every thing and didn’t deliver too much, we learnt how to design. We learnt how to think for ourselves. We learnt how research. We learnt how to reason about trade offs. It took us a while but we also learnt how to avoid binary thinking and refrain our excitement with new trends. The combination of a strong software design foundation with Agile and Lean principles and practices, put us in a much better position today not only to deliver software fast but also to deliver software continuously.&lt;/p&gt;

&lt;p&gt;Our goal is to enable business agility and that can be achieved through software that can be continuously deployed into production. Deploy software to production once is not that hard but to deploy software to production multiple times a day and keep this rhythm for months if not years, well, that’s not so simple. We need a lot of discipline and engineering to achieve continuous delivery, which makes software design and TDD two of the most important technical disciplines we have to master.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Increasing complexity one entity at a time</title>
      <link>http://codurance.com/blog/increasing-complexity-one-entity-at-a-time/</link>
      <pubDate>Mon, 17 Aug 2015 09:35:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/increasing-complexity-one-entity-at-a-time/</guid>
      <description>

&lt;p&gt;While working on one of our internal tools, I decided to make a small comprise and not follow my own advice. We are building a mini CRM tool and the initial requirements were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maintain information about the companies we are dealing with;&lt;/li&gt;
&lt;li&gt;Maintain a list of contacts per company;&lt;/li&gt;
&lt;li&gt;Maintain a list of engagements (projects, training, consultancy) per company.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;NOTE: I’ll omit details of the code, attributes, etc in order to keep this post simple.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Starting small, while building the CRUD for Company, I ended up with a Company entity that looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Company {
     + id: CompanyId
     + name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was all well and good. Then I needed to write code in order to maintain a list of contacts for each company. I ended up with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Contact {
     + id: ContactId;
     + companyId: CompanyId;
     + name: String
     + email: String;
}
 
class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was the beginning of the problems. For the “View Company” page, I needed to display data related to the Company and all its contacts. For the pages that were only dealing with Company data (a page that listed all companies, page for edit/delete company), I didn’t need the contacts information. Should I load the contacts every time I loaded a company? Should I not load them? The problem of not loading the contacts in certain occasions is that, as the code evolves, I would not know if the list of contacts inside Company was empty because the company doesn’t have contacts or because they were not loaded. That’s confusing. Since performance is not a concern in this application, I decided to load the list of contacts every time I needed a company. Problem solved.&lt;/p&gt;

&lt;p&gt;In the next feature I had to maintain engagements (CRUD) for a company. Following the same approach I used for contacts, I ended up with the following entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Engagement {
     + id: EngagementId;
     + companyId: CompanyId;
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}

class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
     + engagements: List[Engagement];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, things got very confusing. I had pages that needed Company and its contacts and engagements. Pages that only needed Company and Engagements, pages that only needed Company and Contacts. But the problems were not only related to what to load and where. I had loads of code that was relying on the Company structure.&lt;/p&gt;

&lt;p&gt;The application is a web app using AngularJS in the front with JSON going to the browser and back into the application. For that, I had JSON converters that would convert JSON to and from objects. I also had quite a lot of tests for my API and inner layers which would use builders to assemble data. In summary, there was quite a lot of code that, in order to satisfy all the features, would rely on the structure of the Company entity. This code “had to know” when contacts and engagements were loaded or not. And of course, that was constantly changing while we were deciding how much information we needed on each page.&lt;/p&gt;

&lt;p&gt;As features stabilised and I made a few more changes in the code, everything was working.&lt;/p&gt;

&lt;h3 id=&#34;the-ripple-effect&#34;&gt;The ripple effect&lt;/h3&gt;

&lt;p&gt;As we thought we were ready to start building other features (dashboard, financial information, forecasts, notes, reminders, follow up actions, etc), we realised we missed something important.&lt;/p&gt;

&lt;p&gt;Some of our projects come through partners (other companies). That means that an engagement may have more than one company involved. This could make the relationship between Company and Engagements a bit different. Maybe the relationship between Company and Engagements wouldn’t be a &lt;em&gt;one to many&lt;/em&gt; anymore. It would probably be a &lt;em&gt;many to many&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Engagement {
     + id: EngagementId;
     + companies: List[Company];
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}

class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
     + engagements: List[Engagement];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I thought that it would be an easy change but I was surprised to see the massive ripple effect that it had in my code. Loads of test data, builders, JSON parsers, and API structure would be impacted and that was not a good feeling. I was really disappointed with myself and quite pissed off to be honest.&lt;/p&gt;

&lt;h3 id=&#34;following-my-own-advice&#34;&gt;Following my own advice&lt;/h3&gt;

&lt;p&gt;A few years ago I came across &lt;a href=&#34;https://en.wikipedia.org/wiki/Command%E2%80%93query_separation&#34;&gt;CQS&lt;/a&gt; and later on &lt;a href=&#34;http://www.cqrsinfo.com/&#34;&gt;CQRS&lt;/a&gt;. At the beginning I didn’t give CQS much attention and it was only with CQRS that I actually understood a different way to design software. Since then, I’ve been a strong advocate of separating the data structures (and yes, I treat entities as data structures) I use to write from the ones I use to read. I’m not talking about independently deployable read/write models, different databases, events, messages, etc. I’m only talking about using different objects to write and read data.&lt;/p&gt;

&lt;h3 id=&#34;fixing-the-problem-1st-solution&#34;&gt;Fixing the problem (1st solution)&lt;/h3&gt;

&lt;p&gt;After another discussion, we decided that an Engagement would always be for a Company but it may have come to us through a partner. That changed things again. So, I decided to do the following: remove all the dependencies (attributes containing other entities or list of entities) from all the entities. Then ended up like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Company {
     + id: CompanyId
     + name: String
}

class Contact {
     + id: ContactId;
     + companyId: CompanyId;
     + name: String
     + email: String;
}

class Engagement {
     + id: EngagementId;
     + companyId: CompanyId;
     + partnerId: Optional[CompanyId];
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this approach, the entities would contain just the data they needed to be persisted.&lt;/p&gt;

&lt;p&gt;But I still had the queries to fix, where many of them would need a combination of these entities. For that, I created “read” objects that would contain exactly the data needed for each query. Some of them looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class CompanyWithContacts {
     + company: Company;
     + contacts: List[Contacts]
}

class CompanyWithContactsAndEngagements {
     + company: Company;
     + contacts: List[Contacts];
     + engagements: List[Engagements];
}

class EngagementWithCompanies {
     + engagement: Engagement;
     + client: Company;
     + partner: Optional[Company];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this approach, each query would return the combination of data that was requested by the delivery mechanism (pages on the website). Changes in how my entities relate to each other didn’t cause a ripple effect of changes any more since just specific queries would break. There were no problems with lazy-load / eager fetch anymore. There were no doubts about empty attributes since there were no attributes anymore. The optional ones could easily be marked as optional (thanks Java 8).&lt;/p&gt;

&lt;h3 id=&#34;fixing-the-problem-2nd-solution&#34;&gt;Fixing the problem (2nd solution)&lt;/h3&gt;

&lt;p&gt;After the fix above, I was reasonably happy since I was able to localise changes when entity relationships changed. But there was a bit more to it. On the positive side, they allowed me to make a single call from a page that needed a combination of data. On the negative side, performance was not a real concern for me and I didn’t want these extra objects with weird names hanging around. I still had to write code to populate them and convert them to JSON.&lt;/p&gt;

&lt;p&gt;I then decided to make multiple calls from my pages. If a page needed a company, a list of contacts and a list of engagements related to that company, I would make three calls from the page. This decision made all the  “read” objects go away and still kept my code very simple.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Keep your entities detached from each other and focus on implementing simple queries from the client. Just move to a single query if performance really proves to be an issue.&lt;/p&gt;

&lt;p&gt;Don’t use ORMs. ORMs would have made my changes even worse as I would have to keep my entities and database synchronised. It’s great to have the freedom to get a record set from the database using whatever query you want and populate your objects the way you want.&lt;/p&gt;

&lt;p&gt;The way we query data changes far more often than the way we persist the data and these changes can slice and dice the data in many different ways. Binding your entities together will only make it harder to satisfy all the queries and will put an unnecessary strain on the code that is only supposed run business logic and store data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cloud Application Design Considerations</title>
      <link>http://codurance.com/blog/cloud-application-design-considerations/</link>
      <pubDate>Fri, 19 Jun 2015 18:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/cloud-application-design-considerations/</guid>
      <description>

&lt;p&gt;When designing applications for the cloud, irrespective of the chosen platform, I have often found it useful to consider four specific topics during my initial discussions; scalability, availability, manageability and feasibility.&lt;/p&gt;

&lt;p&gt;It is important to remember that the items presented under each topic within this article are not an exhaustive list and are aimed only at presenting a starting point for a series of long and detailed conversations with the stakeholders of your project, always the most important part of the design of any application. The aim of these conversations should be to produce an initial high-level design and architecture. This is achieved by considering these four key elements holistically within the domain of the customers project requirements, always remembering to consider the side-effects and trade-offs of any design decision (i.e. what we gain vs. what we lose, or what we make more difficult).&lt;/p&gt;

&lt;h2 id=&#34;scalability&#34;&gt;Scalability&lt;/h2&gt;

&lt;p&gt;Conversations about scalability should focus on any requirement to add additional capacity to the application and related services to handle increases in load and demand. It is particularly important to consider each application tier when designing for scalability, how they should scale individually and how we can avoid contention issues and bottlenecks. Key areas to consider include: &lt;/p&gt;

&lt;h3 id=&#34;capacity&#34;&gt;Capacity&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Will we need to scale individual application layers and, if so, how can we achieve this without affecting availability?&lt;/li&gt;
&lt;li&gt;How quickly will we need to scale individual services?&lt;/li&gt;
&lt;li&gt;How do we add additional capacity to the application or any part of it?&lt;/li&gt;
&lt;li&gt;Will the application need to run at scale 24x7, or can we scale-down outside business hours or at weekends for example?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;platform-data&#34;&gt;Platform / Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Can we work within the constraints of our chosen persistence services while working at scale (database size, transaction throughput, etc.)?&lt;/li&gt;
&lt;li&gt;How can we partition our data to aid scalability within persistence platform constraints (e.g. maximum database sizes, concurrent request limits, etc.)?&lt;/li&gt;
&lt;li&gt;How can we ensure we are making efficient and effective use of platform resources? As a rule of thumb, I generally tend towards a design based on many small instances, rather than fewer large ones.&lt;/li&gt;
&lt;li&gt;Can we collapse tiers to minimise internal network traffic and use of resources, whilst maintaining efficient scalability and future code maintainability?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;load&#34;&gt;Load&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How can we improve the design to avoid contention issues and bottlenecks? For example, can we use queues or a service bus between services in a co-operating producer, competing consumer pattern?&lt;/li&gt;
&lt;li&gt;Which operations could be handled asynchronously to help balance load at peak times?&lt;/li&gt;
&lt;li&gt;How could we use the platform features for rate-leveling (e.g. Azure Queues, Service Bus, etc.)?&lt;/li&gt;
&lt;li&gt;How could we use the platform features for load-balancing (e.g. Azure Traffic Manager, Load Balancer, etc.)? &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;availability&#34;&gt;Availability&lt;/h2&gt;

&lt;p&gt;Availability describes the ability of the solution to operate in a manner useful to the consumer in spite of transient and enduring faults in the application and underlying operating system, network and hardware dependencies. In reality, there is often some crossover between items useful for availability and scalability.
Conversations should cover at least the following items:&lt;/p&gt;

&lt;h3 id=&#34;uptime-guarantees&#34;&gt;Uptime Guarantees&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;What Service Level Agreements (SLA’s) are the products required to meet?&lt;/li&gt;
&lt;li&gt;Can these SLA’s be met? Do the different cloud services we are planning to use all conform to the levels required? Remember that &lt;a href=&#34;http://codurance.com/2015/05/19/working-with-slas/&#34;&gt;SLA’s are composite&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;replication-and-failover&#34;&gt;Replication and failover&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Which parts of the application are most at risk from failure?&lt;/li&gt;
&lt;li&gt;In which parts of the system would a failure have the most impact?&lt;/li&gt;
&lt;li&gt;Which parts of the application could benefit from redundancy and failover options?&lt;/li&gt;
&lt;li&gt;Will data replication services be required?&lt;/li&gt;
&lt;li&gt;Are we restricted to specific geopolitical areas? If so, are all the services we are planning to use available in those areas?&lt;/li&gt;
&lt;li&gt;How do we prevent corrupt data from being replicated?&lt;/li&gt;
&lt;li&gt;Will recovery from a failure put excess pressure on the system? Do we need to implement retry policies and/or a circuit-breaker?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;disaster-recovery&#34;&gt;Disaster recovery&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In the event of a catastrophic failure, how do we rebuild the system?&lt;/li&gt;
&lt;li&gt;How much data, if any, is it acceptable to lose in a disaster recovery scenario?&lt;/li&gt;
&lt;li&gt;How are we handling backups? Do we have a need for backups in addition to data-replication?&lt;/li&gt;
&lt;li&gt;How do we handle “in-flight” messages and queues in the event of a failure?&lt;/li&gt;
&lt;li&gt;Are we idempotent? Can we replay messages?&lt;/li&gt;
&lt;li&gt;Where are we storing our VM images? Do we have a backup?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;What are the acceptable levels of performance? How can we measure that? What happens if we drop below this level?&lt;/li&gt;
&lt;li&gt;Can we make any parts of the system asynchronous as an aid to performance?&lt;/li&gt;
&lt;li&gt;Which parts of the system are the mostly highly contended, and therefore more likely to cause performance issues?&lt;/li&gt;
&lt;li&gt;Are we likely to hit traffic spikes which may cause performance issues? Can we auto-scale or use queue-centric design to cover for this?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;security&#34;&gt;Security&lt;/h3&gt;

&lt;p&gt;This is clearly a huge topic in itself, but a few interesting items to explore which relate directly to cloud-computing include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is the local law and jurisdiction where data is held? Remember to include the countries where failover and metrics data are held too.&lt;/li&gt;
&lt;li&gt;Is there a requirement for federated security (e.g. ADFS with Azure Active Directory)?&lt;/li&gt;
&lt;li&gt;Is this to be a hybrid-cloud application? How are we securing the link between our corporate and cloud networks?&lt;/li&gt;
&lt;li&gt;How do we control access to the administration portal of the cloud provider?&lt;/li&gt;
&lt;li&gt;How do we restrict access to databases, etc. from other services (e.g. IP Address white-lists, etc.)?&lt;/li&gt;
&lt;li&gt;How do we handle regular password changes?&lt;/li&gt;
&lt;li&gt;How does service-decoupling and multi-tenancy affect security?&lt;/li&gt;
&lt;li&gt;How we will deal with operating system and vendor security patches and updates?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;manageability&#34;&gt;Manageability&lt;/h2&gt;

&lt;p&gt;This topic of conversation covers our ability to understand the health and performance of the live system and manage site operations. Some useful cloud specific considerations include:&lt;/p&gt;

&lt;h3 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How are we planning to monitor the application?&lt;/li&gt;
&lt;li&gt;Are we going to use off-the-shelf monitoring services or write our own?&lt;/li&gt;
&lt;li&gt;Where will the monitoring/metrics data be physically stored? Is this in line with data protection policies?&lt;/li&gt;
&lt;li&gt;How much data will our plans for monitoring produce?&lt;/li&gt;
&lt;li&gt;How will we access metrics data and logs? Do we have a plan to make this data useable as volumes increase?&lt;/li&gt;
&lt;li&gt;Is there a requirement for auditing as well as logging?&lt;/li&gt;
&lt;li&gt;Can we afford to lose some metrics/logging/audit data (i.e. can we use an asynchronous design to “fire and forget” to help aid performance)?&lt;/li&gt;
&lt;li&gt;Will we need to alter the level of monitoring at runtime?&lt;/li&gt;
&lt;li&gt;Do we need automated exception reporting?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How do we automate the deployment?&lt;/li&gt;
&lt;li&gt;How do we patch and/or redeploy without disrupting the live system? Can we still meet the SLA’s?&lt;/li&gt;
&lt;li&gt;How do we check that a deployment was successful?&lt;/li&gt;
&lt;li&gt;How do we roll-back an unsuccessful deployment?&lt;/li&gt;
&lt;li&gt;How many environments will we need (e.g. development, test, staging, production) and how will deploy to each of them?&lt;/li&gt;
&lt;li&gt;Will each environment need separate data storage?&lt;/li&gt;
&lt;li&gt;Will each environment need to be available 24x7?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;feasibility&#34;&gt;Feasibility&lt;/h2&gt;

&lt;p&gt;When discussing feasibility we consider the ability to deliver and maintain the system, within budgetary and time constraints. Items worth investigating include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can the SLA’s ever be met (i.e. is there a cloud service provider that can give the uptime guarantees that we need to provide to our customer)?&lt;/li&gt;
&lt;li&gt;Do we have the necessary skills and experience in-house to design and build cloud applications?&lt;/li&gt;
&lt;li&gt;Can we build the application to the design we have within budgetary constraints and a timeframe that makes sense to the business?&lt;/li&gt;
&lt;li&gt;How much will we need to spend on operational costs (cloud providers often have very complex pricing structures)?&lt;/li&gt;
&lt;li&gt;What can we sensibly reduce (scope, SLAs, resilience)?&lt;/li&gt;
&lt;li&gt;What trade-offs are we willing to accept?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The consideration of these four topics (availability, scalability, manageability and feasibility) will help you discover areas in your application that require some cloud-specific thought, specifically in the early stages of a project. The items listed under each are definitely not exhaustive, but should give you a good starting point for discussion.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inflection Point</title>
      <link>http://codurance.com/blog/inflection-point/</link>
      <pubDate>Wed, 17 Jun 2015 02:34:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/inflection-point/</guid>
      <description>

&lt;p&gt;We all say that software design is all about trade-offs but how do we actually reason about it? How do we decide how much code we are going to write for a given task? Is the easiest thing that could possibly work the right approach? The simplest? How do we know the &lt;a href=&#34;http://www.infoq.com/presentations/Simple-Made-Easy&#34;&gt;difference between simple and easy&lt;/a&gt;? Is this even the right question?&lt;/p&gt;

&lt;p&gt;One way or another, subconsciously or not, we always make a decision to start implementing a new behaviour from somewhere. Some of us write just enough code to satisfy the new behaviour. Others write way more code, trying to avoid future rework in case things change or evolve. Many others are somewhere in between.&lt;/p&gt;

&lt;p&gt;Let’s assume the following:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-06-17-inflection-point.jpg&#34; alt=&#34;Inflection Point&#34; title=&#34;Inflection Point&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;On the left hand side, we have the most straightforward solution for a given desired behaviour. On the right hand side, we have infinite possibilities for writing future proof code. The problem with the right side is that we could never write future proof code according to infinite future possibilities. But we can, however, pick a software capability and try to write some future proof code for that. E.g:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We may need to scale this application&lt;/li&gt;
&lt;li&gt;We may have multiple users with different access levels.&lt;/li&gt;
&lt;li&gt;We will need to make it very secure&lt;/li&gt;
&lt;li&gt;We may add more clients (mobile, web, other systems)&lt;/li&gt;
&lt;li&gt;We may have different types of payments (or biddings, or travels, or accommodations, etc)&lt;/li&gt;
&lt;li&gt;We may want to print this to console, generate a PDF, or call a reporting system.&lt;/li&gt;
&lt;li&gt;We may want provide an API so we are prepared for future integrations with other systems.&lt;/li&gt;
&lt;li&gt;etc…&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although we could try, writing code that can remain flexible for the entire lifespan of a project is practically impossible. You will get it wrong, no matter what you do. Besides that, you will be adding complexity all over the place since there is no way we can know for sure which areas of our code base will evolve.&lt;/p&gt;

&lt;p&gt;I don’t think there is a clear solution or guideline for this problem but at least there is a better way to reason about that. I call it inflection point.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Inflection point defines the maximum amount of investment we are comfortable to make in a desired type of flexibility at a given moment in time. Beyond this point, the investment is not worth anymore.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are two ways to reason about the inflection point:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Right-to-left:&lt;/strong&gt; We pick a software capability that we judge to be very important in the near future. We then think about what would be our ideal solution for that software capability. From that point, which may be quite far on the right hand side, we start thinking how we could make our solution more straightforward (probably also cheaper and faster to implement) right now without loosing site of the flexibility we would like to have in the future. We keep discussing how we can simplify the solution until we find a point where making it simpler will mean loose so much flexibility that it will be too expensive to move towards our ideal solution in the future. That is the inflection point, coming from right to left.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Left-to-right:&lt;/strong&gt; We start from the most straightforward solution for a given problem. We then think about what we currently know about the project, features that are definitely going to be implemented next, and the important software capabilities that will need to be provided in the near future. With that knowledge, we can decide how flexible we could make our code right now, moving from a straightforward solution towards a more engineered solution up to a point that the cost of the flexibility we are providing right now is just not worth the effort or it is just to speculative and risky. That’s the inflection point coming from left to right.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inflection-point-as-a-general-guideline&#34;&gt;Inflection point as a general guideline&lt;/h2&gt;

&lt;p&gt;Let’s look at some common scenarios. Take them with a pinch of salt since there are many other factors that could make them invalid or sway the inflection point to a different side. Also, the team’s experience in certain technologies and approaches will also impact on what is considered straightforward and the cost of added flexibility.&lt;/p&gt;

&lt;h3 id=&#34;example-1-separating-page-structure-and-data-on-a-web-application&#34;&gt;Example 1: Separating page structure and data on a web application&lt;/h3&gt;

&lt;p&gt;Should we split a web page structure (HTML) from its data or should we have our backend generate the whole page via a template engine and return the whole page in one go?&lt;/p&gt;

&lt;p&gt;What are we pre-optimising for? What type of flexibility do we want to provide now and what impact would it have in our code?&lt;/p&gt;

&lt;p&gt;Splitting the page structure from data can bring future benefits like a stable RESTful API for other clients (mobile, other systems). It could also make it easier to write automated tests for our application when it comes to the data it returns. Besides that, we can provide a better user experience since the page will load faster or not even reload at all, depending on the implementation (single/multi page). In order to achieve that, we need to use JavaScript in the front end and provide multiple controller methods in the back end. We may need to convert objects to JSON and comply to the REST guidelines. There will be more code in the front and back end, and a few data translation layers. We will probably need to use different programming languages in the front and back end.&lt;/p&gt;

&lt;p&gt;A different approach would be to use a template engine and render the whole pages on the server. That could be “easier” since template engine libraries are quite mature in most major languages and we keep the whole application writing in a single programming language. For back end developers, that can be more straightforward. But what do we loose? Do we have a worse user experience? Well, maybe. Internet connection today is much faster than it was 10-15 years ago, when using AJAX was a must (and also pretty hard—browser wars anyone?). What about the flexibility to add new clients (mobile / other systems)? Can we really foresee what type of API they will need? What about the API granularity? Would it be the same one used for the web?&lt;/p&gt;

&lt;p&gt;Then we have things like team skills set. How familiar are we with all the technologies involved? How concrete are the plans to have a mobile presence? Would it be a native app or a responsive web page would do just fine?&lt;/p&gt;

&lt;p&gt;Do we have a separate web design / UX team? Which approach would be easier to make them part of the team and work on the same code base?&lt;/p&gt;

&lt;p&gt;Where is the inflection point? How much complexity should we add right now? Is some extra code really a big deal for the amount of flexibly we get, even if a bit speculative? Are there any other alternatives to provide a similar flexibility without so much extra code? How much would we pay if we delay the decision to provide the flexibility right now?&lt;/p&gt;

&lt;h3 id=&#34;example-2-knowing-upcoming-features&#34;&gt;Example 2: Knowing upcoming features&lt;/h3&gt;

&lt;p&gt;When our work is most exploratory, I would strongly recommend looking for the most straightforward solution. However, when working in an environment where we have a Product Owner with a clear vision, a product backlog that is carefully maintained, and with big enough budget to guarantee that the project will run for many months, if not years, should we always aim for the most straightforward solution?&lt;/p&gt;

&lt;p&gt;Imagine that we are working on Feature A and that we know that Feature B and C are the next features to be implemented. Also, imagine that they are closely related, that means, Feature B and C will be built on top of the implementation of Feature A.&lt;/p&gt;

&lt;p&gt;In this scenario, should we aim for the most straightforward solution for Feature A and then refactor everything in order to add Feature B and C? How far do we go with the implementation of Feature A when we are 99% sure that Feature B and C are going to implemented immediately after we finish Feature A? But what if we were only 50% sure? Or 20%? Where would the inflection point be?&lt;/p&gt;

&lt;h3 id=&#34;example-3-layers&#34;&gt;Example 3: Layers&lt;/h3&gt;

&lt;p&gt;Many developers use some sort of layered architecture. A common layer would be the data layer that is normally defined by &lt;em&gt;repository&lt;/em&gt; classes.&lt;/p&gt;

&lt;p&gt;In almost 20 years of career, I had only one application that we actually changed our persistency mechanism and the repository layer was extremely useful. Moving from one database to another had almost zero impact in the rest of the code.&lt;/p&gt;

&lt;p&gt;I recently had a few discussions about the data (repository) layer. Some of my colleagues said that this added complexity not always pays off since we are probably not going to change the persistency mechanism. That is a fair comment and normally the repository layer can be seen as future proof code and not the most straightforward solution.&lt;/p&gt;

&lt;p&gt;But what is the alternative? Active Record? Have persistency logic mixed with application logic? Violation of SRP? No separation of concerns? A different type of separation that will be very similar to the repositories but less explicit? Use of a framework? How does it affect transactional boundaries? Should they be in the repository layer or should they be at the entry points of your domain model?&lt;/p&gt;

&lt;p&gt;This is an example where discussing what would be the straightforward solution versus what type of future proof code we want to have may differ a lot from team to team. Some would find a layer of repositories a very cheap price to pay while others would find it too expensive.&lt;/p&gt;

&lt;p&gt;So, instead of discussing the repository layer, we should discuss what type of flexibility we would like to have when it comes to persistency and how much are we wiling to pay for that right now. What would the inflection point be?&lt;/p&gt;

&lt;h3 id=&#34;example-4-architecture-and-high-level-design&#34;&gt;Example 4: Architecture and high-level design&lt;/h3&gt;

&lt;p&gt;Should we start an application with a monolith or with a bunch of micro-services? Or somewhere in between? Normal services? Application modules? Well-defined package/namespace structure? This is not a simple question and the inflection point will change significantly according to the context. Are we working for a small startup with two developers? Are we working with a large company with budget for a multi-year project, which will start with 50 developers from day one? How much do we know about the domain? Are we exploring an idea? Or is it a well-defined domain?&lt;/p&gt;

&lt;p&gt;What are we optimising for? How much does it cost? How complex is the solution? What are the trade offs? Should we pre-optimise for scalability or should we focus on the most straightforward? What do we loose or gain with a given solution? Can we defer this decision to a later stage? Would it be too chaotic to have all the developers working on the same code base? Which software capabilities do we want to have in the first release? What would be the cost to make some architectural decisions in the future?&lt;/p&gt;

&lt;p&gt;I worked in projects where it made sense to start small and grow the application bit-by-bit, focusing on the most straightforward solutions at the beginning. But I also worked in much larger applications where it was too risky or close to impossible to defer certain architectural decisions. The inflection point was completely different in those two contexts.&lt;/p&gt;

&lt;h3 id=&#34;example-5-micro-design&#34;&gt;Example 5: Micro design&lt;/h3&gt;

&lt;p&gt;Many agree that the use of primitives to represent domain concepts is bad. So, should we create types for everything? What is the cost and how much more code do we need to write? Is the amount of code the only concern? Are we trying to reduce the number of bugs in the future? What about languages without types?&lt;/p&gt;

&lt;p&gt;What price do we pay when we create types for everything? Does it really improve readability? What gains do we have in the future? Should we limit type creation to our domain model? When is it OK to use primitives? What is the impact in maintainability and testing? Would we need to write more or less tests when choosing primitives over types? How easy is to create types in our chosen programming language?&lt;/p&gt;

&lt;p&gt;Those are many of the considerations that may define where the inflection point will be.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Over-engineering has a big cost and may cause a lot of damage. However, a long sequence of straightforward solutions may also cause of lot of pain and re-work as the system grows. Every change becomes a huge refactoring task.&lt;/p&gt;

&lt;p&gt;As a general guideline, I prefer to first look at what would be the most straightforward solution and then start exploring a few possibilities to provide more flexibility for future changes given an important software capability (left to right). Also, most straightforward doesn’t mean quick and dirty.&lt;/p&gt;

&lt;p&gt;However, there are times when we know that certain things are very important and considering them in the early stages of a project, or while building a new feature, may be quite beneficial. Maybe the price we pay now for some extra code may be considered a bargain when compared to the amount of flexibility we gain in the future, which will move the inflection point more towards the right.&lt;/p&gt;

&lt;p&gt;Whenever you have a design discussion with your pair or team, focus the discussion on finding the inflection point. This will make the discussion more objective. Instead of “my idea versus yours” or “this approach versus that approach”, we should discuss what type of flexibility we would like to have and how we can achieve that without paying premium for it. How much are we willing to pay? Should we pay for it now, or in the future? Distant or near future? Can we pay in instalments?&lt;/p&gt;

&lt;p&gt;Trying to answer the questions above will help us to reason about our decisions and find a good starting point (inflection point) for new projects or features.&lt;/p&gt;

&lt;p&gt;_Thanks to &lt;a href=&#34;http://twitter.com/SamirTalwar&#34;&gt;Samir Talwar&lt;/a&gt;, &lt;a href=&#34;http://twitter.com/mashooq&#34;&gt;Mashooq Badar&lt;/a&gt;, &lt;a href=&#34;http://twitter.com/tom_b025&#34;&gt;Tom Brand&lt;/a&gt;, and &lt;a href=&#34;http://twitter.com/johan_alps&#34;&gt;Johan Martinsson&lt;/a&gt; for the conversations during &lt;a href=&#34;http://socratesuk.org&#34;&gt;Socrates UK&lt;/a&gt; that led to the clarification of the terminology and ideas described in this post._&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Does TDD really lead to good design?</title>
      <link>http://codurance.com/blog/does-tdd-lead-to-good-design/</link>
      <pubDate>Sat, 09 May 2015 14:32:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/does-tdd-lead-to-good-design/</guid>
      <description>

&lt;p&gt;Recently I tweeted that &lt;a href=&#34;https://twitter.com/sandromancuso/status/588503877235781632&#34;&gt;TDD can’t lead to a good design if we don’t know what good design looks like&lt;/a&gt;. I was also saying that we probably should teach design before TDD (or at least, at the same time). This tweet led to a discussions with &lt;a href=&#34;https://twitter.com/jbrains&#34;&gt;J.B. Rainsberger&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/RonJeffries&#34;&gt;Ron Jeffries&lt;/a&gt;, and a few others. J.B. and I ended up having a live &lt;a href=&#34;https://www.youtube.com/watch?v=ty3p5VDcoOI&#34;&gt;discussion on Hangout on Air&lt;/a&gt; later on.&lt;/p&gt;

&lt;p&gt;If you look back to many of my talks, blogs, and even my book, you will find multiple occasions where I say that TDD is a design tool. So what changed? Why I don’t say the same thing anymore?&lt;/p&gt;

&lt;h3 id=&#34;why-did-i-change-my-mind&#34;&gt;Why did I change my mind?&lt;/h3&gt;

&lt;p&gt;After paying more attention to how I work and how many other developers work, I realised that not many people are driving good design through TDD. Although I love the RED-GREEN-REFACTORING rhythm, having a “refactoring” step is not enough to call TDD a design tool.&lt;/p&gt;

&lt;p&gt;TDD doesn’t prescribe how you should design. What it does is to annoy you constantly, asking “Are you sure about this? Is it good enough? Can you make it better?” This annoyance (or constant reminder to look at your design and thing if it can be improved) is a great thing, but not enough.&lt;/p&gt;

&lt;p&gt;In my view, TDD is a software development &lt;em&gt;workflow&lt;/em&gt; which provides me with many benefits, including a constant reminder to make my code better. What it means to make my code better, is not part of TDD.&lt;/p&gt;

&lt;h4 id=&#34;aren-t-you-forgetting-about-the-4-rules-of-simple-design&#34;&gt;Aren’t you forgetting about the 4 Rules of Simple Design?&lt;/h4&gt;

&lt;p&gt;Ah, yes… But no. I’m not forgetting about them. &lt;a href=&#34;https://twitter.com/sandromancuso/status/589098111559213056&#34;&gt;4 Rules of Simple Design are NOT part of TDD&lt;/a&gt; and I’m purely discussing TDD here. 4 Rules of Simple Design is normally the design guidelines that many experienced TDD practitioners use (including myself, among other techniques) during the refactoring phase.&lt;/p&gt;

&lt;p&gt;4 Rules of Simple Design is one of the many design guidelines we have available. &lt;a href=&#34;http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29&#34;&gt;SOLID&lt;/a&gt; is another. &lt;a href=&#34;http://en.wikipedia.org/wiki/Domain-driven_design&#34;&gt;Domain-Driven Design&lt;/a&gt; is another. Many other design principles and patterns are also available as good guidelines. Those are the things we need to have in our mind during “refactoring” phase. Or, putting it in a different way, having a good understanding of the existing design guidelines is what will lead you to a better design.&lt;/p&gt;

&lt;p&gt;TDD is a workflow (not a design tool) where during the refactoring phase you apply your existing knowledge of software design combined with design techniques that may help you to get to a better design.&lt;/p&gt;

&lt;h3 id=&#34;not-all-tdds-are-the-same&#34;&gt;Not all TDDs are the same&lt;/h3&gt;

&lt;p&gt;There are two main styles of TDD with significant differences between them, mainly when it comes to design.&lt;/p&gt;

&lt;h4 id=&#34;classicist&#34;&gt;Classicist&lt;/h4&gt;

&lt;p&gt;The Classicist approach is the original approach to TDD created by Kent Beck. It’s also known as &lt;em&gt;Detroit School&lt;/em&gt; of TDD.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Main characteristics&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Design happens during the refactoring phase.&lt;/li&gt;
&lt;li&gt;Normally tests are state-based tests.&lt;/li&gt;
&lt;li&gt;During the refactoring phase, the unit under test may grow to multiple classes.&lt;/li&gt;
&lt;li&gt;Mocks are rarely used, unless when isolating external systems.&lt;/li&gt;
&lt;li&gt;No up-front design considerations are made. Design completely emerges from code.&lt;/li&gt;
&lt;li&gt;It’s a great way to avoid over-engineering.&lt;/li&gt;
&lt;li&gt;Easier to understand and adopt due to state-based tests and no design up-front.&lt;/li&gt;
&lt;li&gt;Often used in conjunction with the 4 Rules of Simple Design.&lt;/li&gt;
&lt;li&gt;Good for exploration, when we know what the input and desired output are but we don’t really know how the implementation looks like.&lt;/li&gt;
&lt;li&gt;Great for cases where we can’t rely on a domain expert or domain language (data transformation, algorithms, etc.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Problems&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Exposing state for tests purpose only.&lt;/li&gt;
&lt;li&gt;Refactoring phase is normally bigger when compared to Outside-In approach (more on that below).&lt;/li&gt;
&lt;li&gt;Unit under test becomes bigger than a class when classes emerge during the refactoring phase. This is fine when we look at that test in isolation but as classes emerge, they create life of their own, being reused by other parts of the application. As these other classes evolve, they may break completely unrelated tests, since the tests use their real implementation instead of a mock.&lt;/li&gt;
&lt;li&gt;Refactoring (design improvement) step is often skipped by inexperienced practitioners, leading to a cycle that looks more like RED-GREEN-RED-GREEN-…-RED-GREEN-MASSIVE REFACTORING.&lt;/li&gt;
&lt;li&gt;Due to its exploratory nature, some classes under test are created according to the “I think I’ll need this class with this interface (public methods)”, making them not fit well when connected to the rest of the system.&lt;/li&gt;
&lt;li&gt;Can be slow and wasteful since quite often we already know that we cannot have so many responsibilities in the class under test. The classicist advice is to wait for the refactoring phase to fix the design, only relying on concrete evidence to extract other classes. Although this is good for novices, this is pure waste for more experienced developers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;outside-in&#34;&gt;Outside-In&lt;/h4&gt;

&lt;p&gt;Outside-In TDD, also known as &lt;em&gt;London School&lt;/em&gt; or &lt;em&gt;mockist&lt;/em&gt;, is a TDD style developed and adopted by some of the first XP practitioners in London. It later inspired the creation of BDD.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Main characteristics&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Different from the classicist, Outside-In TDD prescribes a direction in which we start test-driving our code: from outside (first class to receive an external request) to the inside (classes that will contain single pieces of behaviour that satisfy the feature being implemented).&lt;/li&gt;
&lt;li&gt;We normally start with an acceptance test which verifies if the feature as a whole works. The acceptance test also serves as a guide for the implementation.&lt;/li&gt;
&lt;li&gt;With a failing acceptance test informing why the feature is not yet complete (no data returned, no message sent to a queue, no data stored in a database, etc.), we start writing unit tests. The first class to be tested is the class handling an external request (a controller, queue listener, event handler, the entry point for a component, etc.)&lt;/li&gt;
&lt;li&gt;As we already know that we won’t build the entire application in a single class, we make some assumptions of which type of collaborators the class under test will need. We then write tests that verify the collaboration between the class under test and its collaborators.&lt;/li&gt;
&lt;li&gt;Collaborators are identified according to all the things the class under test needs to do when its public method is invoked. Collaborators names and methods should come from the domain language (nouns and verbs).&lt;/li&gt;
&lt;li&gt;Once a class is tested, we pick the first collaborator (which was created with no implementation) and test-drive its behaviour, following the same approach we used for the previous class. This is why we call outside-in: we start from classes that are closer to the input of the system (outside) and move towards the inside of our application as more collaborators are identified.&lt;/li&gt;
&lt;li&gt;Design starts in the &lt;em&gt;red&lt;/em&gt; phase, while writing the tests.&lt;/li&gt;
&lt;li&gt;Tests are about collaboration and behaviour, not state.&lt;/li&gt;
&lt;li&gt;Design is refined during the &lt;em&gt;refactoring&lt;/em&gt; phase.&lt;/li&gt;
&lt;li&gt;Each collaborator and its public methods are always created to &lt;em&gt;serve&lt;/em&gt; an existing client class, making the code read very well.&lt;/li&gt;
&lt;li&gt;Refactoring phases are much smaller, when compared to the classicist approach.&lt;/li&gt;
&lt;li&gt;Promotes a better encapsulation since no state is exposed for test purposes only,&lt;/li&gt;
&lt;li&gt;More aligned to the &lt;em&gt;tell, don’t ask&lt;/em&gt; approach.&lt;/li&gt;
&lt;li&gt;More aligned to the original ideas of Object Oriented Programming: tests are about objects sending messages to other objects instead of checking their state.&lt;/li&gt;
&lt;li&gt;Suitable for business applications, where names and verbs can be  extracted from user stories and acceptance criteria.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Problems&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Much harder for novices to adopt since a higher level of design skill is necessary.&lt;/li&gt;
&lt;li&gt;Developers don’t get feedback from code in order to create collaborators. They need to &lt;em&gt;visualise&lt;/em&gt; collaborators while writing the test.&lt;/li&gt;
&lt;li&gt;May lead to over-engineering due to premature type (collaborators) creation.&lt;/li&gt;
&lt;li&gt;Not suitable for exploratory work or behaviour that is not specified in a user story (data transformation, algorithms, etc).&lt;/li&gt;
&lt;li&gt;Bad design skills may lead to an explosion of mocks.&lt;/li&gt;
&lt;li&gt;Behavioural tests are harder to write than state tests.&lt;/li&gt;
&lt;li&gt;Knowledge of Domain Driven Design and other design techniques, including 4 Rules of Simple Design, are required while writing tests.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;which-tdd-style-should-we-use&#34;&gt;Which TDD style should we use?&lt;/h3&gt;

&lt;p&gt;Both. All. They are just tools and as such, they should be used according to your needs. Experienced TDD practitioners jump from one style to another without ever worrying which style they are using.&lt;/p&gt;

&lt;h3 id=&#34;macro-and-micro-design&#34;&gt;Macro and micro design&lt;/h3&gt;

&lt;p&gt;There are two types of design: macro and micro design. Micro design is what we do while test driving code, mainly using the classicist approach. Macro design goes beyond the feature we are implementing. It’s about how we model our domain at a much higher level, how we split our application, layers, services, etc. Macro design helps us with the overall organisation of the application and provides ways for teams and developers to work in parallel without stepping on each other toes. Macro design refers to how the business sees the application and techniques like Domain-Driven Design are commonly used. Macro design also helps with consistency throughout the application. TDD won’t help you with macro design.&lt;/p&gt;

&lt;p&gt;Macro design is normally taken into account when using Outside-In TDD, but Outside-In on its own is not enough to define the macro design of an application.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Over the years I’ve seen many applications that have been test-driven and were still a pain to work with. OK, I admit that they were significantly better than the majority of the legacy applications which had no tests that I had to maintain before that.&lt;/p&gt;

&lt;p&gt;Any developer can make a mess regardless if they are writing tests or not. Developers can also test drive crap regardless of which TDD style they are using.&lt;/p&gt;

&lt;p&gt;TDD is &lt;strong&gt;not&lt;/strong&gt; a design tool. It’s a software development &lt;em&gt;workflow&lt;/em&gt; that has prompts for code improvement in its lifecycle. In these prompts (writing tests and refactoring), developers need to know some design guidelines (4 Rules of Simple Design, Domain Driven Design, SOLID, Patterns, Law of Demeter, Tell, Don’t Ask, POLA/S, Design by Contract, Feature Envy, cohesion, coupling, Balanced Abstraction Principle, etc) in order to make their code better. Just saying &lt;em&gt;refactoring&lt;/em&gt; isn’t enough to call TDD a design tool.&lt;/p&gt;

&lt;p&gt;Many developers blame TDD and mocks for slowing them down. They end up giving up on TDD because they struggle to get the result they want. In my opinion, no developer really struggles to understand the RED-GREEN-REFACTOR lifecycle. What they struggle with is how to design software well.&lt;/p&gt;

&lt;p&gt;The great thing about TDD is that it is constantly asking us “Hey, can you make your code better? See how hard testing this class is becoming? OK, you made it work. Here’s your green bar. Now make it better.” Besides that, you are on your own.&lt;/p&gt;

&lt;p&gt;TDD becomes much easier when we understand what good design looks like. Practicing and understanding the wealth of design guidelines available will make TDD much easier and useful. It will also reduce its learning curve and hopefully increase its adoption.&lt;/p&gt;

&lt;p&gt;Extremes are bad. We are going from BDUF (Big Design Up Front) to &lt;em&gt;no design at all&lt;/em&gt;. Throwing away our design knowledge is a mistake. Sure, we should not go back to the dark ages and over-engineer everything but thinking that we should only focus on micro design is also a mistake. If you are working on your own, doing a few katas, or working on a small application, then yes, do whatever you like. But if you are part of bigger team developing something that is significantly bigger than a kata, you will be doing your team a favour if you paid more attention to macro design and how you structure your code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Balanced Abstraction Principle</title>
      <link>http://codurance.com/blog/balanced-abstraction-principle/</link>
      <pubDate>Tue, 27 Jan 2015 10:30:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/balanced-abstraction-principle/</guid>
      <description>

&lt;p&gt;One of the things that make code complicated to read and understand is when the instructions inside a method are at different levels of abstraction.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that our application only allows the logged-in user to see trips from her friends. If users are not friends, no trips should be displayed.&lt;/p&gt;

&lt;p&gt;An example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public List&amp;lt;Trip&amp;gt; tripsByFriend(User user, User loggedInUser) {
    return (user.friends().contains(loggedInUser))    
                    ? userRepository.findTripsBy(user.id())
                    : Collections.emptyList();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, all the instructions in the body of the method are in different levels of abstraction. We have instructions validating friendship, instructions that fetch the list of trips of a friend via a collaborator, and a low level Java API that return an empty and immutable list. On top of that, we have the business behaviour itself.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at a refactored version of the same method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public List&amp;lt;Trip&amp;gt; tripsByFriend(User user, User loggedInUser) {
    return (user.isFriendsWith(loggedInUser)) 
                    ? tripsBy(user)
                    : noTrips();
}

private List&amp;lt;Trip&amp;gt; tripsBy(User user) {
    userRepository.findTripsBy(friend.id());
}

private List&amp;lt;Trip&amp;gt; noTrips() {
    return Collections.emptyList();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this new version, we extracted the low-level abstractions to private methods and also moved some behaviour to the User class. With this change, all the instructions are on the same level of abstraction, making it clear what the business rule is. The public method is now telling us a story, without worrying about technical implementation details. The code now reads without any bumps: &amp;ldquo;If user is friends with the logged-in user, return trips by user, otherwise return no trips.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;balanced-abstraction-principle-bap&#34;&gt;Balanced Abstraction Principle (BAP)&lt;/h3&gt;

&lt;p&gt;The Balanced Abstraction Principle defines that all code constructs grouped by a higher-level construct should be on the same level of abstraction. That means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All instructions inside a method should be at the same level of abstraction&lt;/li&gt;
&lt;li&gt;All public methods inside a class should be at the same level of abstraction&lt;/li&gt;
&lt;li&gt;All classes inside a package/namespace&lt;/li&gt;
&lt;li&gt;All sibling packages/namespace inside a parent package/namespace&lt;/li&gt;
&lt;li&gt;All modules, sub-systems, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The principle also applies to tests—all tests for a single unit (method, class, module, system) should be at the same level of abstraction.&lt;/p&gt;

&lt;h3 id=&#34;bap-and-srp&#34;&gt;BAP and SRP&lt;/h3&gt;

&lt;p&gt;Code that complies with the Single Responsibility Principle has a higher chance to also be compliant to the Balanced Abstraction Principle. However, this is not always the case and the opposite is not always true.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In order to achieve well-crafted code, we need to take many design principles into consideration and I believe that the Balanced Abstraction Principle (BAP) is a missing piece in the SOLID principles and overall software design.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Highly Strung</title>
      <link>http://codurance.com/blog/highly-strung/</link>
      <pubDate>Thu, 02 Oct 2014 13:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/highly-strung/</guid>
      <description>&lt;p&gt;This blog post is way overdue.&lt;/p&gt;

&lt;p&gt;A couple of months ago, I wrote a talk entitled &lt;a href=&#34;http://samirtalwar.github.io/talks/highly-strung.html&#34;&gt;Highly Strung&lt;/a&gt; for the &lt;a href=&#34;http://virtualjug.com/&#34;&gt;Virtual Java User Group (vJUG)&lt;/a&gt; on when and how to use strings in your code.&lt;/p&gt;

&lt;p&gt;Spoiler: don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;So this blog post is really just to ask you to check it out if you&amp;rsquo;re interested. The link&amp;rsquo;s up top, and has the talk in essay form, the slides &lt;em&gt;and&lt;/em&gt; the video, lovingly recorded by the folks who run the vJUG.&lt;/p&gt;

&lt;p&gt;Go on, &lt;a href=&#34;http://samirtalwar.github.io/talks/highly-strung.html&#34;&gt;check it out&lt;/a&gt;. I want to tell you something else, but afterwards.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;OK, now the cool bit. Go back to that page and click on the &amp;ldquo;Presentation&amp;rdquo; link in the top-right corner, and watch as the page &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; reload.&lt;/p&gt;

&lt;p&gt;OK, funky JavaScript. Who cares?&lt;/p&gt;

&lt;p&gt;Well, that&amp;rsquo;s because the essay and the slides are the same HTML document (give or take). It&amp;rsquo;s just markup and a little bit of JavaScript to get the ball rolling.&lt;/p&gt;

&lt;p&gt;If you look at the HTML source of the document, you&amp;rsquo;ll see that there are lots of &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; blocks. Each one is a slide in the presentation. Inside those are lots of &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; blocks with a class of &lt;code&gt;notes&lt;/code&gt;. In presentation mode, these are hidden. And it&amp;rsquo;s &lt;a href=&#34;https://github.com/SamirTalwar/talks/blob/gh-pages/index.md&#34;&gt;all Markdown&lt;/a&gt; under the hood, rendered by GitHub Pages, so it&amp;rsquo;s just a static site.&lt;/p&gt;

&lt;p&gt;And, well, that&amp;rsquo;s about it. All that &amp;ldquo;Presentation&amp;rdquo; link does is change the CSS class on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; to tell the document to hide the notes (and show a few extra things), and load up &lt;a href=&#34;https://github.com/hakimel/reveal.js&#34;&gt;reveal.js&lt;/a&gt;. Shiny, huh?&lt;/p&gt;

&lt;p&gt;The only thing I&amp;rsquo;m missing is a way to get back to the essay form. Currently I reload the page, because there seems to be no way to unload reveal.js once it&amp;rsquo;s loaded, but that&amp;rsquo;s not so bad, y&amp;rsquo;know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tell don&#39;t ask</title>
      <link>http://codurance.com/blog/tell-dont-ask/</link>
      <pubDate>Sun, 27 Jul 2014 12:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/tell-dont-ask/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Tell don&amp;rsquo;t ask&lt;/strong&gt; we have all heard it. Yet it is one of the most violated principles. It is also one of the most important principles to follow if you want a design that is flexible to change.&lt;/p&gt;

&lt;p&gt;I have often heard people say, &lt;strong&gt;&amp;rdquo;&amp;hellip; but it makes Test driving very hard&amp;rdquo;&lt;/strong&gt;. I disagree - what it does is stop you from testing at too granular a level and focus on testing behaviours rather than interactions.&lt;/p&gt;

&lt;p&gt;Enough postulating &amp;hellip; here is an example taken from my current work. You have an interface to an external system - you have nicely encapsulated it into your own class and throw an exception if, for example, there are infra level issues. Once the exception is raised - you let it percolate to the top and create an alert to inform operations.&lt;/p&gt;

&lt;p&gt;The diagram below depicts a more usual approach I&amp;rsquo;ve seen:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/ask-not-tell.png&#34; alt=&#34;Ask! not tell&#34; title=&#34;Ask! not tell&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Chances are that we test drove the &lt;em&gt;Infra Service&lt;/em&gt; knowing that it needs to have all the right details required for us to raise the &lt;em&gt;Alert&lt;/em&gt;. However, we are not testing that the right Alert is created because that is not the responsibility of the &lt;em&gt;Infra Service&lt;/em&gt;. Hence we poke a few holes in the &lt;em&gt;Infra Exception&lt;/em&gt; class and assert that the exception is created with the right details.&lt;/p&gt;

&lt;p&gt;Once we move to implementing the &lt;em&gt;A Service&lt;/em&gt; we have all the relevant details exposed from the exception so we retrieve these details and create the &lt;em&gt;Alert&lt;/em&gt;. Interesting that the real behaviour here is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;create alert with the right details if there is an infra error&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;create exception with the right details if there is an infra error and then create alert from exception with the right details&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now lets looks at the alternative. Lets say we drove the test from the outside, i.e. &lt;em&gt;A Service&lt;/em&gt;, and did not mock the &lt;em&gt;Infra Service&lt;/em&gt; but instead mocked the &lt;em&gt;External System API&lt;/em&gt;.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/tell-dont-ask.png&#34; alt=&#34;Tell! don&amp;#39;t ask&#34; title=&#34;Tell! don&amp;#39;t ask&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;We end up with a tell-don&amp;rsquo;t-ask approach where we are testing that the right &lt;em&gt;Alert&lt;/em&gt; is created when there is an infra error. We also end up with fewer interactions and a more flexible design. If for example we decided to encapsulate the external system some other way, our tests will not need to change.&lt;/p&gt;

&lt;p&gt;Although testing at this level provides us with far less brittle tests, the disadvantage is that parts of the implementation is further way. On the other hand there are far fewer reasons why a test may break during refactoring.&lt;/p&gt;

&lt;p&gt;Finding the right level to test is not a science. We need to take complexity of the unit-under-test into account. The rule of the thumb is that we should test from outside and mock external boundaries until the tests get too complex and only then get more granular for the more complex parts striving to maintain flexible tests and simple design.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Queue Based Synchronisation</title>
      <link>http://codurance.com/blog/queue-based-synchronisation/</link>
      <pubDate>Tue, 15 Jul 2014 12:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/queue-based-synchronisation/</guid>
      <description>&lt;p&gt;The first rule of using locks for thread synchronisation is, &lt;strong&gt;&amp;ldquo;Do NOT use them!&amp;rdquo;&lt;/strong&gt;. Recently I saw an implementation that made heavy use of locks to synchronise access to a shared cache between two threads. The overall approach is explained in the diagram below:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/lock-based-synchronisation.jpg&#34; alt=&#34;Lock based synchronisation&#34; title=&#34;Lock based synchronisation&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Why not do the whole thing in a single thread? Well! the operations to the External Store are very time consuming and Thread-1 does not need to wait for them. So how do you solve this without using lock-based synchronisation?&lt;/p&gt;

&lt;p&gt;The operations to the cache are very quick and can be done in a single thread. These operations are coming from multiple threads. We can funnel them through a single thread by using a thread-safe queue as explained in the following diagram:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/queue-based-synchronisation.jpg&#34; alt=&#34;Queue based synchronisation&#34; title=&#34;Queue based synchronisation&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Although this solution looks more complicated, the key advantage is that no low-level thread synchronisation is needed. Most good programming languages already provide thread-safe queues. Also, you can scale up using a thread pool for the operations to the external store.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: in both of the above approaches we need to ensure that the cache does not grow indefinitely. In case of the queue based approach we can use a a queue that blocks after a maximum capacity is reached. In case of the lock based approach the cache itself will need to block.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>