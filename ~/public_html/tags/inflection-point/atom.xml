<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Inflection Point on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/inflection-point/</link>
    <description>Recent content in Inflection Point on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 12 Apr 2016 00:24:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/inflection-point/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>We did it wrong, but not all was in vain</title>
      <link>http://codurance.com/blog/we-did-it-wrong-but-not-in-vain/</link>
      <pubDate>Tue, 12 Apr 2016 00:24:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/we-did-it-wrong-but-not-in-vain/</guid>
      <description>&lt;p&gt;Yes, there was over engineering. Loads of it. Back in the mid 90s, when I started my career as a developer, the goal was to become an architect. No serious developer would dare writing a single line of code before selecting our preferred design patterns—we would then decide how the business requirements would fit into them. Yes, we would first come up with our architecture, then our macro design (layers) and domain model (including UML diagrams), and then we would think about the business requirements and detailed use cases. Yes, user stories were not really a thing back then. We had long use cases with a basic flow and many alternative flows.&lt;/p&gt;

&lt;p&gt;The 90s were an interesting period to be a developer. We finally had the Internet and a few academic papers on structured design from 70s and 80s became available to us. We also had a few books focusing on Object-Oriented Programming, still a novelty in many places.&lt;/p&gt;

&lt;p&gt;I still remember the countless months we spent drawing class, sequence, component, deployment, and many other diagrams, trying to come up with the best design for the software that one day we would build. We built some prototypes as well, so I can’t say we were not coding or experimenting during the &lt;em&gt;elaboration phase&lt;/em&gt;. All the learnings from the prototypes would be fed back into our diagrams, of course.&lt;/p&gt;

&lt;p&gt;Besides the internal design, in the 90s we had an explosion of distributed systems as well. We had CORBA and DCOM. We had client/server and multi-tier architecture. We learnt about single point of failure when using databases as a communication point between applications. Yes, we had nasty problems with that. We learnt how to create “services”—SOA was emerging as an architectural concept. We learnt how to think about scalability and security. Many projects outside governments and banks were also becoming very large and complex.&lt;/p&gt;

&lt;p&gt;Creating a great design was the goal for most passionate software developers; it was also the path to become an architect and career evolution. We had to study and be good at software design. We had to understand in depth principles of structured and object-oriented design. We had to understand principles of distributed system. We had to understand in depth all levels of cohesion and coupling. We had to understand covariance and contravariance. We had to learn how to design components boundaries including their contracts and invariant. We had to learn to how to understand verbs and nouns, the language of the business, and map them into software. We would never pass a job interview without knowing how to model data in our relational databases, and mostly important, how to make our queries perform well. We had to define our proprietary protocols in the right granularity in order to make it easier for other systems to consume them and at the same time address I/O and bandwidth concerns. Yes, we spent a lot of time doing that.&lt;/p&gt;

&lt;p&gt;Software development in the 90s was all about design and architecture. And yes, it had to be done with UML.&lt;/p&gt;

&lt;p&gt;But although we learnt how to design, we failed in many other aspects. We didn’t deliver fast enough. In fact, in some projects we didn’t deliver anything at all. Most of the times, all the thinking we did trying to create a perfect design was completely wasted due to lack of quick feedback and our inability to cope with rapid business evolution. I still remember the huge spreadsheets we used to control change requests even before we had any code written. Yes, we screwed up big time. Many times.&lt;/p&gt;

&lt;p&gt;Fast-forwarding 20 years, some of us understood what we were doing was wrong. We then incorporated Agile, Lean, and many other principles and practices into the way we work. We incorporated many new design and architecture techniques into our tool kit. We incorporated new technologies. We incorporated different ways to collaborate with the business and also how to structure our teams. We learned that although design was important, nothing was more important than continuously delivering software. We learnt how to get feedback and iterate. We learnt we were responsible to test our own code. We learnt we had to support our software in production. We learnt the value of creating prototypes and throwing them away. We learnt the value of experimentation. But we also learnt we didn’t need to throw away all the design skills we acquired over the years in order to work in a better way. We didn’t need to discard all the great work done before and during our time, mainly around software design during the 70s, 80s and 90s. But the most important lesson we learnt was that context is king and that software design is all about trade offs. Design is pointless without delivery. But can we keep delivering code without a solid design foundation? I don’t think so.&lt;/p&gt;

&lt;p&gt;One of the biggest problems I see today in software design is binary thinking. If X is bad, than Y must be good. If X worked for company A, than it will also work for us. If a well-known person said something in a 45-minute talk in a conference or we found something written in a blog, it must be true. Always.&lt;/p&gt;

&lt;p&gt;Another common mistake caused by binary thinking is the belief that all features in a software project have the same degree of complexity and a single design choice will fit them all. But the truth is, some features are quite simple, others very complex, and many others are somewhere in between. Sometimes the complexity is found in the implementation; other times it is found on understanding and modelling the domain. Sometimes the complexity is in understanding what we should be building. Other times the complexity is in the integration with other systems. Parts of the same feature can also vary a lot in complexity: some parts may be trivial and quickly implemented while others can be extremely complex and demand a lot thinking up front. Some features are shallow (very few lines of code) while others are deep (thousands of lines of code spread through different modules). Non-functional requirements can also make the implementation of simple features (business-wise) very complex. And the interesting thing is that all of that can be found within the same software project. So, if we agree that different features in a software project have different degrees of complexity and size, there is no way we can apply binary thinking into software design—no single design approach will ever work in a reasonably complex software project.&lt;/p&gt;

&lt;p&gt;We live in a world where information is easily and quickly accessible. One search on Google and we can find many ready-made solutions to our problems. My fear is that, as an industry, we are losing the ability to think. We are losing the ability to research and make our own choices. More and more we are looking for a ready-made recipe. A shortcut. I call them a “Stack Overflow solution.”&lt;/p&gt;

&lt;p&gt;It makes me sad that, to some people, software design is synonymous of over-engineering. It also makes me sad to see that &amp;ldquo;no design at all” is becoming synonymous of Agile, Lean Startup, and fast delivery. I don’t think the originators and main proponents of good software design, Agile, and Lean principles ever meant that. Over-engineering is bad, but so is no design at all. Simple doesn’t mean crap. Simple means just enough design for what we know today, but not less. Paraphrasing Einstein, software design should be made as simple as possible, but not simpler. Or another way of putting it: code must be well-designed but not over-designed.&lt;/p&gt;

&lt;p&gt;After interviewing a lot of developers and reviewing a lot of code in the past few years, my main concern is that we are developing a hacker culture. Many developers I met who have been in the industry for less than a decade, have very little knowledge of good software design. They will claim otherwise, of course. If you think I’m exaggerating, ask developers in your team to explain cohesion and its different levels. Ask them about connascence, covariance and contravariance. Ask them about different degrees and types of coupling. Ask them about design by contract and invariant. For those that have heard about SOLID principles ask them where the SOLID principles came from. Many developers today say design patterns are bad. Ask them to describe some patterns, their differences, and when they should or should not be applied. Ask them about the different pattern classifications. Ask them about the difference between a Bridge, Adapter, and Mediator. What problem a Visitor is supposed to solve? Ask them what is a Memento? If they can’t explain that, how can they say patterns are bad?&lt;/p&gt;

&lt;p&gt;Many developers today are not aware of the software design foundation laid during the 70s, 80s, and 90s. Others prefer to ignore it: &lt;em&gt;That is over-engineering and they don’t need that.&lt;/em&gt; That’s fine, I can respect that. But why do we still have software that sucks then? Is the software being produced today really better than the software being produced 20 years ago? Why developers still struggle to design code with TDD? Why are we still talking about legacy code? For me, legacy code is synonymous of code that is badly designed, hence difficult to test and maintain.&lt;/p&gt;

&lt;p&gt;By no means I’m defending over-engineering or wasting time drawing diagrams in UML. What I’m trying to say is that at the same time I would never spend hours to design classes inside my core domain up front, I would also not try to build an enterprise application, one test at a time, without thinking about its overall design before start coding. Design is essential for software development. If I’m building an application that will live in an ecosystem alongside many applications, or with heavy non-functional requirements, or that needs to comply to regulations, yes, of course I would put a lot of thought about its overall structure (macro-design) before I start coding but I would still develop its features (“micro-level”) one test at a time. Design happens at all levels: from up-front at the architectural level to just-in-time at micro level as part of my TDD flow. Decide how much to design is a skill—it&amp;rsquo;s all about finding the &lt;a href=&#34;http://codurance.com/2015/06/17/inflection-point/&#34;&gt;inflection point&lt;/a&gt;, subject I covered on a &lt;a href=&#34;http://codurance.com/2015/06/17/inflection-point/&#34;&gt;previous blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Software design is one of the most important skills in software development. Good design enables developers to collaborate, business features to be added and changed frequently, and reliable test automation to be done. With experience, we learn how to quickly identify problems and decide the amount of time we should spend on it. We also learn that most design decisions should be made in the last responsible moment, that means, we try not to commit to a design too early, while we don’t know enough about the problem.&lt;/p&gt;

&lt;p&gt;And that’s why I say that not everything we did in the 90s was in vain. Although we over-engineered every thing and didn’t deliver too much, we learnt how to design. We learnt how to think for ourselves. We learnt how research. We learnt how to reason about trade offs. It took us a while but we also learnt how to avoid binary thinking and refrain our excitement with new trends. The combination of a strong software design foundation with Agile and Lean principles and practices, put us in a much better position today not only to deliver software fast but also to deliver software continuously.&lt;/p&gt;

&lt;p&gt;Our goal is to enable business agility and that can be achieved through software that can be continuously deployed into production. Deploy software to production once is not that hard but to deploy software to production multiple times a day and keep this rhythm for months if not years, well, that’s not so simple. We need a lot of discipline and engineering to achieve continuous delivery, which makes software design and TDD two of the most important technical disciplines we have to master.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Increasing complexity one entity at a time</title>
      <link>http://codurance.com/blog/increasing-complexity-one-entity-at-a-time/</link>
      <pubDate>Mon, 17 Aug 2015 09:35:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/increasing-complexity-one-entity-at-a-time/</guid>
      <description>

&lt;p&gt;While working on one of our internal tools, I decided to make a small comprise and not follow my own advice. We are building a mini CRM tool and the initial requirements were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maintain information about the companies we are dealing with;&lt;/li&gt;
&lt;li&gt;Maintain a list of contacts per company;&lt;/li&gt;
&lt;li&gt;Maintain a list of engagements (projects, training, consultancy) per company.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;NOTE: I’ll omit details of the code, attributes, etc in order to keep this post simple.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Starting small, while building the CRUD for Company, I ended up with a Company entity that looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Company {
     + id: CompanyId
     + name: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was all well and good. Then I needed to write code in order to maintain a list of contacts for each company. I ended up with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Contact {
     + id: ContactId;
     + companyId: CompanyId;
     + name: String
     + email: String;
}
 
class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was the beginning of the problems. For the “View Company” page, I needed to display data related to the Company and all its contacts. For the pages that were only dealing with Company data (a page that listed all companies, page for edit/delete company), I didn’t need the contacts information. Should I load the contacts every time I loaded a company? Should I not load them? The problem of not loading the contacts in certain occasions is that, as the code evolves, I would not know if the list of contacts inside Company was empty because the company doesn’t have contacts or because they were not loaded. That’s confusing. Since performance is not a concern in this application, I decided to load the list of contacts every time I needed a company. Problem solved.&lt;/p&gt;

&lt;p&gt;In the next feature I had to maintain engagements (CRUD) for a company. Following the same approach I used for contacts, I ended up with the following entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Engagement {
     + id: EngagementId;
     + companyId: CompanyId;
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}

class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
     + engagements: List[Engagement];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, things got very confusing. I had pages that needed Company and its contacts and engagements. Pages that only needed Company and Engagements, pages that only needed Company and Contacts. But the problems were not only related to what to load and where. I had loads of code that was relying on the Company structure.&lt;/p&gt;

&lt;p&gt;The application is a web app using AngularJS in the front with JSON going to the browser and back into the application. For that, I had JSON converters that would convert JSON to and from objects. I also had quite a lot of tests for my API and inner layers which would use builders to assemble data. In summary, there was quite a lot of code that, in order to satisfy all the features, would rely on the structure of the Company entity. This code “had to know” when contacts and engagements were loaded or not. And of course, that was constantly changing while we were deciding how much information we needed on each page.&lt;/p&gt;

&lt;p&gt;As features stabilised and I made a few more changes in the code, everything was working.&lt;/p&gt;

&lt;h3 id=&#34;the-ripple-effect&#34;&gt;The ripple effect&lt;/h3&gt;

&lt;p&gt;As we thought we were ready to start building other features (dashboard, financial information, forecasts, notes, reminders, follow up actions, etc), we realised we missed something important.&lt;/p&gt;

&lt;p&gt;Some of our projects come through partners (other companies). That means that an engagement may have more than one company involved. This could make the relationship between Company and Engagements a bit different. Maybe the relationship between Company and Engagements wouldn’t be a &lt;em&gt;one to many&lt;/em&gt; anymore. It would probably be a &lt;em&gt;many to many&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Engagement {
     + id: EngagementId;
     + companies: List[Company];
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}

class Company {
     + id: CompanyId;
     + name: String;
     + contacts: List[Contact];
     + engagements: List[Engagement];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I thought that it would be an easy change but I was surprised to see the massive ripple effect that it had in my code. Loads of test data, builders, JSON parsers, and API structure would be impacted and that was not a good feeling. I was really disappointed with myself and quite pissed off to be honest.&lt;/p&gt;

&lt;h3 id=&#34;following-my-own-advice&#34;&gt;Following my own advice&lt;/h3&gt;

&lt;p&gt;A few years ago I came across &lt;a href=&#34;https://en.wikipedia.org/wiki/Command%E2%80%93query_separation&#34;&gt;CQS&lt;/a&gt; and later on &lt;a href=&#34;http://www.cqrsinfo.com/&#34;&gt;CQRS&lt;/a&gt;. At the beginning I didn’t give CQS much attention and it was only with CQRS that I actually understood a different way to design software. Since then, I’ve been a strong advocate of separating the data structures (and yes, I treat entities as data structures) I use to write from the ones I use to read. I’m not talking about independently deployable read/write models, different databases, events, messages, etc. I’m only talking about using different objects to write and read data.&lt;/p&gt;

&lt;h3 id=&#34;fixing-the-problem-1st-solution&#34;&gt;Fixing the problem (1st solution)&lt;/h3&gt;

&lt;p&gt;After another discussion, we decided that an Engagement would always be for a Company but it may have come to us through a partner. That changed things again. So, I decided to do the following: remove all the dependencies (attributes containing other entities or list of entities) from all the entities. Then ended up like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Company {
     + id: CompanyId
     + name: String
}

class Contact {
     + id: ContactId;
     + companyId: CompanyId;
     + name: String
     + email: String;
}

class Engagement {
     + id: EngagementId;
     + companyId: CompanyId;
     + partnerId: Optional[CompanyId];
     + name: String
     + startDate: Date;
     + endDate: Date;
     + description: String;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this approach, the entities would contain just the data they needed to be persisted.&lt;/p&gt;

&lt;p&gt;But I still had the queries to fix, where many of them would need a combination of these entities. For that, I created “read” objects that would contain exactly the data needed for each query. Some of them looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class CompanyWithContacts {
     + company: Company;
     + contacts: List[Contacts]
}

class CompanyWithContactsAndEngagements {
     + company: Company;
     + contacts: List[Contacts];
     + engagements: List[Engagements];
}

class EngagementWithCompanies {
     + engagement: Engagement;
     + client: Company;
     + partner: Optional[Company];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this approach, each query would return the combination of data that was requested by the delivery mechanism (pages on the website). Changes in how my entities relate to each other didn’t cause a ripple effect of changes any more since just specific queries would break. There were no problems with lazy-load / eager fetch anymore. There were no doubts about empty attributes since there were no attributes anymore. The optional ones could easily be marked as optional (thanks Java 8).&lt;/p&gt;

&lt;h3 id=&#34;fixing-the-problem-2nd-solution&#34;&gt;Fixing the problem (2nd solution)&lt;/h3&gt;

&lt;p&gt;After the fix above, I was reasonably happy since I was able to localise changes when entity relationships changed. But there was a bit more to it. On the positive side, they allowed me to make a single call from a page that needed a combination of data. On the negative side, performance was not a real concern for me and I didn’t want these extra objects with weird names hanging around. I still had to write code to populate them and convert them to JSON.&lt;/p&gt;

&lt;p&gt;I then decided to make multiple calls from my pages. If a page needed a company, a list of contacts and a list of engagements related to that company, I would make three calls from the page. This decision made all the  “read” objects go away and still kept my code very simple.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Keep your entities detached from each other and focus on implementing simple queries from the client. Just move to a single query if performance really proves to be an issue.&lt;/p&gt;

&lt;p&gt;Don’t use ORMs. ORMs would have made my changes even worse as I would have to keep my entities and database synchronised. It’s great to have the freedom to get a record set from the database using whatever query you want and populate your objects the way you want.&lt;/p&gt;

&lt;p&gt;The way we query data changes far more often than the way we persist the data and these changes can slice and dice the data in many different ways. Binding your entities together will only make it harder to satisfy all the queries and will put an unnecessary strain on the code that is only supposed run business logic and store data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inflection Point</title>
      <link>http://codurance.com/blog/inflection-point/</link>
      <pubDate>Wed, 17 Jun 2015 02:34:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/inflection-point/</guid>
      <description>

&lt;p&gt;We all say that software design is all about trade-offs but how do we actually reason about it? How do we decide how much code we are going to write for a given task? Is the easiest thing that could possibly work the right approach? The simplest? How do we know the &lt;a href=&#34;http://www.infoq.com/presentations/Simple-Made-Easy&#34;&gt;difference between simple and easy&lt;/a&gt;? Is this even the right question?&lt;/p&gt;

&lt;p&gt;One way or another, subconsciously or not, we always make a decision to start implementing a new behaviour from somewhere. Some of us write just enough code to satisfy the new behaviour. Others write way more code, trying to avoid future rework in case things change or evolve. Many others are somewhere in between.&lt;/p&gt;

&lt;p&gt;Let’s assume the following:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-06-17-inflection-point.jpg&#34; alt=&#34;Inflection Point&#34; title=&#34;Inflection Point&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;On the left hand side, we have the most straightforward solution for a given desired behaviour. On the right hand side, we have infinite possibilities for writing future proof code. The problem with the right side is that we could never write future proof code according to infinite future possibilities. But we can, however, pick a software capability and try to write some future proof code for that. E.g:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We may need to scale this application&lt;/li&gt;
&lt;li&gt;We may have multiple users with different access levels.&lt;/li&gt;
&lt;li&gt;We will need to make it very secure&lt;/li&gt;
&lt;li&gt;We may add more clients (mobile, web, other systems)&lt;/li&gt;
&lt;li&gt;We may have different types of payments (or biddings, or travels, or accommodations, etc)&lt;/li&gt;
&lt;li&gt;We may want to print this to console, generate a PDF, or call a reporting system.&lt;/li&gt;
&lt;li&gt;We may want provide an API so we are prepared for future integrations with other systems.&lt;/li&gt;
&lt;li&gt;etc…&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although we could try, writing code that can remain flexible for the entire lifespan of a project is practically impossible. You will get it wrong, no matter what you do. Besides that, you will be adding complexity all over the place since there is no way we can know for sure which areas of our code base will evolve.&lt;/p&gt;

&lt;p&gt;I don’t think there is a clear solution or guideline for this problem but at least there is a better way to reason about that. I call it inflection point.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Inflection point defines the maximum amount of investment we are comfortable to make in a desired type of flexibility at a given moment in time. Beyond this point, the investment is not worth anymore.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are two ways to reason about the inflection point:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Right-to-left:&lt;/strong&gt; We pick a software capability that we judge to be very important in the near future. We then think about what would be our ideal solution for that software capability. From that point, which may be quite far on the right hand side, we start thinking how we could make our solution more straightforward (probably also cheaper and faster to implement) right now without loosing site of the flexibility we would like to have in the future. We keep discussing how we can simplify the solution until we find a point where making it simpler will mean loose so much flexibility that it will be too expensive to move towards our ideal solution in the future. That is the inflection point, coming from right to left.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Left-to-right:&lt;/strong&gt; We start from the most straightforward solution for a given problem. We then think about what we currently know about the project, features that are definitely going to be implemented next, and the important software capabilities that will need to be provided in the near future. With that knowledge, we can decide how flexible we could make our code right now, moving from a straightforward solution towards a more engineered solution up to a point that the cost of the flexibility we are providing right now is just not worth the effort or it is just to speculative and risky. That’s the inflection point coming from left to right.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inflection-point-as-a-general-guideline&#34;&gt;Inflection point as a general guideline&lt;/h2&gt;

&lt;p&gt;Let’s look at some common scenarios. Take them with a pinch of salt since there are many other factors that could make them invalid or sway the inflection point to a different side. Also, the team’s experience in certain technologies and approaches will also impact on what is considered straightforward and the cost of added flexibility.&lt;/p&gt;

&lt;h3 id=&#34;example-1-separating-page-structure-and-data-on-a-web-application&#34;&gt;Example 1: Separating page structure and data on a web application&lt;/h3&gt;

&lt;p&gt;Should we split a web page structure (HTML) from its data or should we have our backend generate the whole page via a template engine and return the whole page in one go?&lt;/p&gt;

&lt;p&gt;What are we pre-optimising for? What type of flexibility do we want to provide now and what impact would it have in our code?&lt;/p&gt;

&lt;p&gt;Splitting the page structure from data can bring future benefits like a stable RESTful API for other clients (mobile, other systems). It could also make it easier to write automated tests for our application when it comes to the data it returns. Besides that, we can provide a better user experience since the page will load faster or not even reload at all, depending on the implementation (single/multi page). In order to achieve that, we need to use JavaScript in the front end and provide multiple controller methods in the back end. We may need to convert objects to JSON and comply to the REST guidelines. There will be more code in the front and back end, and a few data translation layers. We will probably need to use different programming languages in the front and back end.&lt;/p&gt;

&lt;p&gt;A different approach would be to use a template engine and render the whole pages on the server. That could be “easier” since template engine libraries are quite mature in most major languages and we keep the whole application writing in a single programming language. For back end developers, that can be more straightforward. But what do we loose? Do we have a worse user experience? Well, maybe. Internet connection today is much faster than it was 10-15 years ago, when using AJAX was a must (and also pretty hard—browser wars anyone?). What about the flexibility to add new clients (mobile / other systems)? Can we really foresee what type of API they will need? What about the API granularity? Would it be the same one used for the web?&lt;/p&gt;

&lt;p&gt;Then we have things like team skills set. How familiar are we with all the technologies involved? How concrete are the plans to have a mobile presence? Would it be a native app or a responsive web page would do just fine?&lt;/p&gt;

&lt;p&gt;Do we have a separate web design / UX team? Which approach would be easier to make them part of the team and work on the same code base?&lt;/p&gt;

&lt;p&gt;Where is the inflection point? How much complexity should we add right now? Is some extra code really a big deal for the amount of flexibly we get, even if a bit speculative? Are there any other alternatives to provide a similar flexibility without so much extra code? How much would we pay if we delay the decision to provide the flexibility right now?&lt;/p&gt;

&lt;h3 id=&#34;example-2-knowing-upcoming-features&#34;&gt;Example 2: Knowing upcoming features&lt;/h3&gt;

&lt;p&gt;When our work is most exploratory, I would strongly recommend looking for the most straightforward solution. However, when working in an environment where we have a Product Owner with a clear vision, a product backlog that is carefully maintained, and with big enough budget to guarantee that the project will run for many months, if not years, should we always aim for the most straightforward solution?&lt;/p&gt;

&lt;p&gt;Imagine that we are working on Feature A and that we know that Feature B and C are the next features to be implemented. Also, imagine that they are closely related, that means, Feature B and C will be built on top of the implementation of Feature A.&lt;/p&gt;

&lt;p&gt;In this scenario, should we aim for the most straightforward solution for Feature A and then refactor everything in order to add Feature B and C? How far do we go with the implementation of Feature A when we are 99% sure that Feature B and C are going to implemented immediately after we finish Feature A? But what if we were only 50% sure? Or 20%? Where would the inflection point be?&lt;/p&gt;

&lt;h3 id=&#34;example-3-layers&#34;&gt;Example 3: Layers&lt;/h3&gt;

&lt;p&gt;Many developers use some sort of layered architecture. A common layer would be the data layer that is normally defined by &lt;em&gt;repository&lt;/em&gt; classes.&lt;/p&gt;

&lt;p&gt;In almost 20 years of career, I had only one application that we actually changed our persistency mechanism and the repository layer was extremely useful. Moving from one database to another had almost zero impact in the rest of the code.&lt;/p&gt;

&lt;p&gt;I recently had a few discussions about the data (repository) layer. Some of my colleagues said that this added complexity not always pays off since we are probably not going to change the persistency mechanism. That is a fair comment and normally the repository layer can be seen as future proof code and not the most straightforward solution.&lt;/p&gt;

&lt;p&gt;But what is the alternative? Active Record? Have persistency logic mixed with application logic? Violation of SRP? No separation of concerns? A different type of separation that will be very similar to the repositories but less explicit? Use of a framework? How does it affect transactional boundaries? Should they be in the repository layer or should they be at the entry points of your domain model?&lt;/p&gt;

&lt;p&gt;This is an example where discussing what would be the straightforward solution versus what type of future proof code we want to have may differ a lot from team to team. Some would find a layer of repositories a very cheap price to pay while others would find it too expensive.&lt;/p&gt;

&lt;p&gt;So, instead of discussing the repository layer, we should discuss what type of flexibility we would like to have when it comes to persistency and how much are we wiling to pay for that right now. What would the inflection point be?&lt;/p&gt;

&lt;h3 id=&#34;example-4-architecture-and-high-level-design&#34;&gt;Example 4: Architecture and high-level design&lt;/h3&gt;

&lt;p&gt;Should we start an application with a monolith or with a bunch of micro-services? Or somewhere in between? Normal services? Application modules? Well-defined package/namespace structure? This is not a simple question and the inflection point will change significantly according to the context. Are we working for a small startup with two developers? Are we working with a large company with budget for a multi-year project, which will start with 50 developers from day one? How much do we know about the domain? Are we exploring an idea? Or is it a well-defined domain?&lt;/p&gt;

&lt;p&gt;What are we optimising for? How much does it cost? How complex is the solution? What are the trade offs? Should we pre-optimise for scalability or should we focus on the most straightforward? What do we loose or gain with a given solution? Can we defer this decision to a later stage? Would it be too chaotic to have all the developers working on the same code base? Which software capabilities do we want to have in the first release? What would be the cost to make some architectural decisions in the future?&lt;/p&gt;

&lt;p&gt;I worked in projects where it made sense to start small and grow the application bit-by-bit, focusing on the most straightforward solutions at the beginning. But I also worked in much larger applications where it was too risky or close to impossible to defer certain architectural decisions. The inflection point was completely different in those two contexts.&lt;/p&gt;

&lt;h3 id=&#34;example-5-micro-design&#34;&gt;Example 5: Micro design&lt;/h3&gt;

&lt;p&gt;Many agree that the use of primitives to represent domain concepts is bad. So, should we create types for everything? What is the cost and how much more code do we need to write? Is the amount of code the only concern? Are we trying to reduce the number of bugs in the future? What about languages without types?&lt;/p&gt;

&lt;p&gt;What price do we pay when we create types for everything? Does it really improve readability? What gains do we have in the future? Should we limit type creation to our domain model? When is it OK to use primitives? What is the impact in maintainability and testing? Would we need to write more or less tests when choosing primitives over types? How easy is to create types in our chosen programming language?&lt;/p&gt;

&lt;p&gt;Those are many of the considerations that may define where the inflection point will be.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Over-engineering has a big cost and may cause a lot of damage. However, a long sequence of straightforward solutions may also cause of lot of pain and re-work as the system grows. Every change becomes a huge refactoring task.&lt;/p&gt;

&lt;p&gt;As a general guideline, I prefer to first look at what would be the most straightforward solution and then start exploring a few possibilities to provide more flexibility for future changes given an important software capability (left to right). Also, most straightforward doesn’t mean quick and dirty.&lt;/p&gt;

&lt;p&gt;However, there are times when we know that certain things are very important and considering them in the early stages of a project, or while building a new feature, may be quite beneficial. Maybe the price we pay now for some extra code may be considered a bargain when compared to the amount of flexibility we gain in the future, which will move the inflection point more towards the right.&lt;/p&gt;

&lt;p&gt;Whenever you have a design discussion with your pair or team, focus the discussion on finding the inflection point. This will make the discussion more objective. Instead of “my idea versus yours” or “this approach versus that approach”, we should discuss what type of flexibility we would like to have and how we can achieve that without paying premium for it. How much are we willing to pay? Should we pay for it now, or in the future? Distant or near future? Can we pay in instalments?&lt;/p&gt;

&lt;p&gt;Trying to answer the questions above will help us to reason about our decisions and find a good starting point (inflection point) for new projects or features.&lt;/p&gt;

&lt;p&gt;_Thanks to &lt;a href=&#34;http://twitter.com/SamirTalwar&#34;&gt;Samir Talwar&lt;/a&gt;, &lt;a href=&#34;http://twitter.com/mashooq&#34;&gt;Mashooq Badar&lt;/a&gt;, &lt;a href=&#34;http://twitter.com/tom_b025&#34;&gt;Tom Brand&lt;/a&gt;, and &lt;a href=&#34;http://twitter.com/johan_alps&#34;&gt;Johan Martinsson&lt;/a&gt; for the conversations during &lt;a href=&#34;http://socratesuk.org&#34;&gt;Socrates UK&lt;/a&gt; that led to the clarification of the terminology and ideas described in this post._&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>