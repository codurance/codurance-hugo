<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ddd on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/ddd/</link>
    <description>Recent content in Ddd on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Mon, 26 Oct 2015 09:35:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/ddd/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Talk to the business</title>
      <link>http://codurance.com/blog/Talk-to-the-business/</link>
      <pubDate>Mon, 26 Oct 2015 09:35:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/Talk-to-the-business/</guid>
      <description>&lt;p&gt;Almost a month ago, I did this amazing course at &lt;a href=&#34;https://skillsmatter.com/&#34;&gt;SkillsMatter&lt;/a&gt;: &lt;a href=&#34;https://skillsmatter.com/courses/202-domain-model&#34;&gt;&amp;ldquo;Eric Evans Domain Driven Design Immersion Workshop&amp;rdquo;&lt;/a&gt;. The course was very intensive and provided me with the opportunity to reinforce a lot of concepts I already knew as well as learn a few more.&lt;/p&gt;

&lt;p&gt;One of this concepts was &lt;a href=&#34;http://c2.com/cgi/wiki?UbiquitousLanguage&#34;&gt;Ubiquitous Language&lt;/a&gt;. The first time I heard it from our coach &lt;a href=&#34;https://twitter.com/ziobrando&#34;&gt;Alberto Brandolini&lt;/a&gt;, I must confess I understood &amp;ldquo;Ambiguous Language&amp;rdquo;. The term &amp;ldquo;Ubiquitous&amp;rdquo; it&amp;rsquo;s not a simple one, especially for a non-native English speaker like myself. While I was listening to the coach explaining all of this concepts around the &amp;ldquo;Ubiquitous Language&amp;rdquo;, another one did make its way through: &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-driven_design#Bounded_context&#34;&gt;&amp;ldquo;Bounded Context&amp;rdquo;&lt;/a&gt;.
&lt;a href=&#34;http://martinfowler.com/bliki/BoundedContext.html&#34;&gt;Martin Fowler&lt;/a&gt; has a really nice post where he defines it like this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD&amp;rsquo;s strategic design section which is all about dealing with large models and teams. DDD deals with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One thing that Alberto told us was that we should always consider our bounded context when talking to the business expert: in the same company, different concepts may be used for the same term, whether you are talking to a sales expert or an accounting expert. So it&amp;rsquo;s up to us, developers, to define in which context we are currently working.&lt;/p&gt;

&lt;p&gt;The videos that they showed to us during the course were very helpful: I definitely saw myself in previous clients doing the same mistakes and not understanding what was going on. The good thing is that now I know how to address it, and even did it twice in my current client.&lt;/p&gt;

&lt;p&gt;So the next time that you hear a business expert using a different word from the ones that you&amp;rsquo;re using, go and talk to them. Make sure the words you are using are the correct ones, and if there&amp;rsquo;s a new one then you should integrate it into your model. After all, they are the ones who know the business!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Keeping the domain in the core</title>
      <link>http://codurance.com/blog/keeping-the-domain-in-core/</link>
      <pubDate>Thu, 10 Apr 2014 00:30:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/keeping-the-domain-in-core/</guid>
      <description>&lt;p&gt;Inspired by Alistair Cockburn&amp;rsquo;s excellent &lt;a href=&#34;http://alistair.cockburn.us/Hexagonal+architecture&#34;&gt;article&lt;/a&gt; on Hexagonal Architecture, on our current project we have kept the core domain of our application independent of the infrastructure by taking the simple decision to divide our code into two main sections (higher level packages): infrastructure and core.&lt;/p&gt;

&lt;p&gt;The infrastructure section depends on the core but the core knows nothing about the infrastructure - the domain is uncontaminated by infrastructure concerns.&lt;/p&gt;

&lt;p&gt;This makes testing the application from a business perspective simpler and more efficient because the tests do not need to worry about the infrastructure. We can also write more focused integration tests for the infrastructure components by mocking out the core dependencies. Furthermore, keeping the domain free from other supporting concerns empowers the team to continuously refine and refactor their model as their understanding of the domain improves and evolves.&lt;/p&gt;

&lt;p&gt;Considering our example of consuming from a messaging service: we need to decide whether it is a corrupt message, and for non-corrupt messages a further check is required to see if it is a duplicate, before we can deem it valid. This can be nicely divided into infrastructure and core. The following UML diagram shows the dependencies.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/keeping_domain_in_core.png&#34; alt=&#34;UML Diagram for example&#34; title=&#34;UML Diagram for example&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;The JMS Message Listener is only concerned with the delivery of the message. How that message is handled, once received, is independent of the infrastructure. The Received Message in this case is an interface implemented by JMS Received Message that lives in the infrastructure package. Here we use dependency inversion to ensure that the core does not depend on the infrastructure package.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>