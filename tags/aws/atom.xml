<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aws on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/aws/</link>
    <description>Recent content in Aws on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Wed, 11 May 2016 00:20:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/aws/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>AWS Lambda for Beginners</title>
      <link>http://codurance.com/blog/aws-lambdas/</link>
      <pubDate>Wed, 11 May 2016 00:20:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/aws-lambdas/</guid>
      <description>

&lt;p&gt;AWS Lambda is a compute service from Amazon. It makes deployment and provisioning very simple and fits very well with microservices based architecture. You can find out more about AWS Lambda &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34;&gt;here&lt;/a&gt;. Currently supported platforms are JVM, Node JS and Python.&lt;/p&gt;

&lt;p&gt;The programming model for the lambdas consists of &lt;strong&gt;Handler, Context Object, Logging and Exceptions&lt;/strong&gt;. These are described &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html&#34;&gt;here&lt;/a&gt;. Lambda must not hold state because they are brought up and down and replicated as needed. Persistent state should be stored in a service that is outside the lifecycle of the lambda such as Amazon DynamoDB, S3 etc.&lt;/p&gt;

&lt;p&gt;First of all follow the instructions &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/setup.html&#34;&gt;here&lt;/a&gt; to setup an AWS Account and AWS Command-line Interface and note down your account id.&lt;/p&gt;

&lt;h3 id=&#34;step-1-the-code&#34;&gt;Step 1: The Code&lt;/h3&gt;

&lt;p&gt;The most basic lambda will look like the following in Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lambda_handler(event, context):
  return &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or like the following in Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package example;

import com.amazonaws.services.lambda.runtime.Context; 

public class Hello {
    public String lambdaHandler(String event, Context context) {
        return &amp;quot;Hello World!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can follow the, somewhat lengthy, instructions &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/get-started-create-function.html&#34;&gt;here&lt;/a&gt; to deploy this function … but that’s no fun! Let’s do it devops style ;)&lt;/p&gt;

&lt;p&gt;Paste the above Python code in a file called &lt;code&gt;helloworld.py&lt;/code&gt;. If you want to use the Java version then follow the instructions &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/java-create-jar-pkg-maven-no-ide.html&#34;&gt;here&lt;/a&gt; to build your lambda and create a deployment package using Maven.&lt;/p&gt;

&lt;h3 id=&#34;step-2-the-role&#34;&gt;Step 2: The Role&lt;/h3&gt;

&lt;p&gt;Create a &lt;code&gt;trust.json&lt;/code&gt; file . The trust allows our function to assume the &lt;a href=&#34;http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html&#34;&gt;role&lt;/a&gt; of an AWS Lambda.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;trust.json&lt;/code&gt; we are allowing the function to assume the role of a &lt;code&gt;lambda.amazonaws.com&lt;/code&gt; service, otherwise the infra will not allow our function to run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
  &amp;quot;Statement&amp;quot;: [{
    &amp;quot;Sid&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
    &amp;quot;Principal&amp;quot;: {
      &amp;quot;Service&amp;quot;: &amp;quot;lambda.amazonaws.com&amp;quot;
    },
    &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-3-the-deployment&#34;&gt;Step 3: The Deployment&lt;/h3&gt;

&lt;p&gt;Create the following script (&lt;code&gt;deploy.sh&lt;/code&gt;). &lt;em&gt;Note: the script assumes that you have the &lt;code&gt;AWS_ACCOUNT_ID&lt;/code&gt; environment variable set.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

### Create the lambda package
zip -j helloworld.zip *.py

### Create the role for the lambda to assume
role=&amp;quot;helloworld_exec_role&amp;quot;
trust=&amp;quot;trust.json&amp;quot;
aws iam create-role --role-name $role --assume-role-policy-document file://$trust
aws iam update-assume-role-policy --role-name $role --policy-document file://$trust

### Create the lambda function
function_name=&amp;quot;helloworld&amp;quot;
handler_name=&amp;quot;helloworld.lambda_handler&amp;quot;
package_file=helloworld.zip
runtime=python2.7
aws lambda create-function \
  --function-name $function_name \
  --handler $handler_name \
  --runtime $runtime \
  --memory 512 \
  --timeout 60 \
  --role arn:aws:iam::${AWS_ACCOUNT_ID}:role/$role \
  --zip-file fileb://$package_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or for Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

### Create the lambda package
mvn package

### Create the role for the lambda to assume
role=&amp;quot;helloworld_exec_role&amp;quot;
trust=&amp;quot;trust.json&amp;quot;
aws iam create-role --role-name $role --assume-role-policy-document file://$trust
aws iam update-assume-role-policy --role-name $role --policy-document file://$trust

### Create the lambda function
function_name=&amp;quot;helloworld&amp;quot;
handler_name=&amp;quot;example.Hello::lambdaHandler&amp;quot;
package_file=&amp;quot;target/lambda-java-example-1.0-SNAPSHOT.jar&amp;quot;
runtime=&amp;quot;java8&amp;quot;
aws lambda create-function \
  --function-name $function_name \
  --handler $handler_name \
  --runtime $runtime \
  --memory 512 \
  --timeout 60 \
  --role arn:aws:iam::${AWS_ACCOUNT_ID}:role/$role \
  --zip-file fileb://${package_file}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make the script executable &lt;code&gt;chmod +x deploy.sh&lt;/code&gt; and deploy your lambda &lt;code&gt;./deploy.sh&lt;/code&gt;. You may get the following error: &amp;ldquo;The role defined for the function cannot be assumed by Lambda.&amp;rdquo; This is because the role has not been replicated through in the Amazon infra. Just run the deploy script again. It will complain that the role already exists but this time the lambda creation should pass. In the future we will look at a status check to make sure that the role has been fully created before we deploy the function.&lt;/p&gt;

&lt;h3 id=&#34;step-5-the-execution&#34;&gt;Step 5: The Execution!&lt;/h3&gt;

&lt;p&gt;Invoke your lambda with the below command. You should see the result in the file called &lt;code&gt;output.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;aws lambda invoke --invocation-type RequestResponse --function-name helloworld --payload &#39;[&amp;quot;&amp;quot;]&#39; output.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-6-the-cleanup&#34;&gt;Step 6: The Cleanup&lt;/h3&gt;

&lt;p&gt;To delete the lambda function and then the role paste the following in &lt;code&gt;delete.sh&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
role=&amp;quot;helloworld_exec_role&amp;quot;
function_name=&amp;quot;helloworld&amp;quot;
aws lambda delete-function --function-name $function_name
aws iam delete-role --role-name $role
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then make the script executable &lt;code&gt;chmod +x delete.sh&lt;/code&gt; and execute &lt;code&gt;./delete.sh&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-7-relax-you-have-arrived&#34;&gt;Step 7: Relax &amp;hellip; you have arrived ;)&lt;/h3&gt;

&lt;p&gt;&amp;hellip; and wait for the next post on AWS frolics&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shape your infrastructure with Terraform</title>
      <link>http://codurance.com/blog/shape-your-infrastructure-with-terraform/</link>
      <pubDate>Tue, 30 Jun 2015 12:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/shape-your-infrastructure-with-terraform/</guid>
      <description>

&lt;p&gt;The popularity of cloud infrastructure services has hugely increased over the last few years. Companies value the flexibility and reliability provided by such services. The simplicity of the solutions delivered by cloud providers should remove the burden from the shoulders of busy Dev and Ops people and give the possibility to focus on real customer&amp;rsquo;s needs.&lt;/p&gt;

&lt;p&gt;Unfortunately the reality is not necessarily so simple. When you start your journey in the cloud you will discover new challenges. One of these challenges will be connected with the creation and provisioning of your new infrastructure. Simple structures can be created within minutes using web pages or a CLI, but these are not the best ways to create a cloud with 100 machines.&lt;/p&gt;

&lt;p&gt;AWS provides many different interfaces which allow automation of an infrastructure process. You can use a REST API or CLI to create your own script. This is probably the most flexible solution, but at the same time it can be time consuming.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://terraform.io/&#34;&gt;Terraform&lt;/a&gt; from HashiCorp can give you similar flexibility and at the same time you don&amp;rsquo;t have to spend weeks to write bash or python scripts to provision your cloud.&lt;/p&gt;

&lt;h2 id=&#34;terraform-for-the-rescue-plan-apply-update-destroy&#34;&gt;Terraform for the rescue - plan, apply, update, destroy.&lt;/h2&gt;

&lt;h3 id=&#34;plan&#34;&gt;Plan&lt;/h3&gt;

&lt;h4 id=&#34;infrastructure-diagram&#34;&gt;Infrastructure diagram&lt;/h4&gt;

&lt;p&gt;
&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/terraform/ShapeYourInfrastructure_VPC.png&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;

To demonstrate the use of Terraform we need to introduce some example infrastructure: let&amp;rsquo;s provision a structure which will support a simple web service running in AWS. This web service will expose an API via a web proxy server. The service also requires a database and this database should have a separate EC2 instance to ease database maintenance. Instances responsible for business logic will be hidden in a private subnet and only the web proxy
server will be available to the wider internet. At the same time our service needs to connect to external resources - therefore a NAT instance will take the responsibility of managing network connections from within the private subnet. All of these resources will constitute a single &lt;a href=&#34;http://aws.amazon.com/vpc/&#34;&gt;Virtual Private Cloud&lt;/a&gt; (VPC).&lt;/p&gt;

&lt;h4 id=&#34;provider&#34;&gt;Provider&lt;/h4&gt;

&lt;p&gt;We are now ready to introduce Terraform. We need to create configuration files which will describe components required to build our infrastructure. Configuration files can be written in &lt;a href=&#34;https://terraform.io/docs/configuration/&#34;&gt;HashiCorp Configuration Language&lt;/a&gt; (similar to YAML) or JSON. All configuration files should have extension &lt;strong&gt;&lt;em&gt;.tf&lt;/em&gt;&lt;/strong&gt; and be stored in the same directory. Terraform automatically combines all resources defined in &lt;strong&gt;&lt;em&gt;.tf&lt;/em&gt;&lt;/strong&gt; files.&lt;/p&gt;

&lt;p&gt;Before we add any resource we have know where our resources are going to exist. To do that we have to create a &lt;em&gt;provider&lt;/em&gt; definition.&lt;/p&gt;

&lt;p&gt;Terraform&amp;rsquo;s provider is the mechanism used for managing resources, in our case we&amp;rsquo;ll use the AWS provider. Our first configuration file might look like this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;provider &amp;quot;aws&amp;quot; {
    access_key = &amp;quot;ACCESS_KEY_HERE&amp;quot;
    secret_key = &amp;quot;SECRET_KEY_HERE&amp;quot;
    region     = &amp;quot;eu-west-1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously we don&amp;rsquo;t want to keep our secrets in a file which will potentially be stored in version control.
We also want to have flexibility when we define a region in which we want to provision our environment. Terraform gives us the possibility to introduce variables.&lt;/p&gt;

&lt;p&gt;First we have to declare the variables we want to use (see &lt;strong&gt;&lt;em&gt;provider-variables.tf&lt;/em&gt;&lt;/strong&gt;). The variables declaration introduces names, structure and default values for all variables used in the configuration file. We will override these default values later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;provider&amp;quot; {
    default = {
        access_key = &amp;quot;not undefined yet&amp;quot;
        secret_key = &amp;quot;not undefined yet&amp;quot;
        region     = &amp;quot;not undefined yet&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can update &lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;provider-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;provider &amp;quot;aws&amp;quot; {
    access_key = &amp;quot;${var.provider.access_key}&amp;quot;
    secret_key = &amp;quot;${var.provider.secret_key}&amp;quot;
    region     = &amp;quot;${var.provider.region}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vpc&#34;&gt;VPC&lt;/h4&gt;

&lt;p&gt;When we know how to connect to our provider we can introduce resources. A resource definition in Terraform contains information about the type of a resource and its name. Types of resources are predefined by Terraform and represent building elements which we can instantiate in the cloud. Each resource also has a predefined set of config properties which describe the resource in detail. For a full list of supported AWS resource types, see &lt;a href=&#34;https://www.terraform.io/docs/providers/aws/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Resource Syntax&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;lt;TYPE&amp;gt; &amp;lt;NAME&amp;gt; {
    &amp;lt;config_key&amp;gt; = &amp;lt;config_value&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our case we have to define a VPC for all our resources to reside in. We need to assign our VPC to a specific range of addresses by defining a &lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR&lt;/a&gt; block. Each VPC also needs an internet gateway.&lt;/p&gt;

&lt;p&gt;Once again instead of hardcoded values we will declare variables specific for our VPC definition.&lt;/p&gt;

&lt;p&gt;We can also introduce a variable which defines the name of our environment. This name will allow us to tag resources and recognise to which environment a given resource belongs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;environment-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;environment_name&amp;quot; {
    default = &amp;quot;unknown-environment&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;vpc-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_vpc&amp;quot; &amp;quot;environment&amp;quot; {
    cidr_block = &amp;quot;${var.vpc.cidr_block}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-vpc&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_internet_gateway&amp;quot; &amp;quot;environment&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-internet-gateway&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;vpc-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;vpc&amp;quot; {
    default = {
        owner_id = &amp;quot;unknown&amp;quot;
        cidr_block = &amp;quot;10.changeit.0.0/16&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the type of a resource and its name as a reference variable to access properties exposed by a given resource, as we did to reference the VPC id above. Some properties of a resource will be defined by Terraform during creation of the resource, like internal ids or names. Some are already defined in our scripts.&lt;/p&gt;

&lt;p&gt;In the above example we assign an internet gateway to our VPC by referencing the property *&lt;strong&gt;id&lt;/strong&gt; of &lt;strong&gt;&lt;em&gt;aws_vpc&lt;/em&gt;&lt;/strong&gt; resource with name &lt;strong&gt;&lt;em&gt;environment&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;subnets&#34;&gt;Subnets&lt;/h4&gt;

&lt;p&gt;Our example VPC should contain two subnets. For each subnet we have to define a range of addresses available (CIDR block), an availability zone and of course we have to assign this subnet to the VPC. Again, we declare variables instead defining values directly in the configuration script.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;subnets-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_subnet&amp;quot; &amp;quot;public-subnet&amp;quot; {
    vpc_id            = &amp;quot;${aws_vpc.environment.id}&amp;quot;
    cidr_block        = &amp;quot;${var.vpc_public_subnet.cidr_block}&amp;quot;
    availability_zone = &amp;quot;${var.vpc_public_subnet.availability_zone}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-public-subnet&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_subnet&amp;quot; &amp;quot;private-subnet&amp;quot; {
    vpc_id            = &amp;quot;${aws_vpc.environment.id}&amp;quot;
    cidr_block        = &amp;quot;${var.vpc_private_subnet.cidr_block}&amp;quot;
    availability_zone = &amp;quot;${var.vpc_private_subnet.availability_zone}&amp;quot;

    tags {
        Name        = &amp;quot;${var.environment_name}-private-subnet&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;subnets-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;vpc&amp;quot; {
    default = {
        owner_id = &amp;quot;unknown&amp;quot;
        cidr_block = &amp;quot;10.changeit.0.0/16&amp;quot;
    }
}

variable &amp;quot;vpc_public_subnet&amp;quot; {
    default = {
        cidr_block = &amp;quot;10.changeit.0.0/24&amp;quot;
        availability_zone = &amp;quot;changeit&amp;quot;
    }
}

variable &amp;quot;vpc_private_subnet&amp;quot; {
    default = {
        cidr_block = &amp;quot;10.changeit.1.0/24&amp;quot;
        availability_zone = &amp;quot;changeit&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;route-tables&#34;&gt;Route tables&lt;/h4&gt;

&lt;p&gt;Each subnet in a VPC must be associated with a route table. This time we have an unusual situation. We have the reference to a resource which was not defined yet (&lt;strong&gt;&lt;em&gt;${aws_instance.nat.id}&lt;/em&gt;&lt;/strong&gt;). The order of files is not important for Terraform. It combines all files and based on that knowledge prepares a plan of execution. For that reason we can refer to resources which are defined in different files. Terraform will produce an error during creation if the resource is not defined anywhere.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;route_tables-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_route_table&amp;quot; &amp;quot;public-subnet&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    route {
        cidr_block = &amp;quot;0.0.0.0/0&amp;quot;
        gateway_id = &amp;quot;${aws_internet_gateway.environment.id}&amp;quot;
    }

    tags {
        Name        = &amp;quot;${var.environment_name}-public-subnet-route-table&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_route_table_association&amp;quot; &amp;quot;public-subnet&amp;quot; {
    subnet_id      = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    route_table_id = &amp;quot;${aws_route_table.public-subnet.id}&amp;quot;
}

resource &amp;quot;aws_route_table&amp;quot; &amp;quot;private-subnet&amp;quot; {
    vpc_id = &amp;quot;${aws_vpc.environment.id}&amp;quot;

    route {
        cidr_block  = &amp;quot;0.0.0.0/0&amp;quot;
        instance_id = &amp;quot;${aws_instance.nat.id}&amp;quot;
    }

    tags {
        Name        = &amp;quot;${var.environment_name}-private-subnet-route-table&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_route_table_association&amp;quot; &amp;quot;private-subnet&amp;quot; {
    subnet_id      = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    route_table_id = &amp;quot;${aws_route_table.private-subnet.id}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;security-groups&#34;&gt;Security groups&lt;/h4&gt;

&lt;p&gt;A definition of any EC2 instance requires assigning it to a security group. Security groups are another type of resource in Terraform. Once again configuration of this resource type is straightforward. Depending on our needs we can define inbound (ingress) and outbound (egress) rules for the desired range of ports, protocols and addresses.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;security_groups-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_security_group&amp;quot; &amp;quot;nat&amp;quot; {
    name = &amp;quot;${var.environment_name}-nat&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    egress {
        from_port   = 80
        to_port     = 80
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-nat-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_security_group&amp;quot; &amp;quot;public&amp;quot; {
    name = &amp;quot;${var.environment_name}-public&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }
(...)
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = &amp;quot;-1&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }

    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-public-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_security_group&amp;quot; &amp;quot;private&amp;quot; {
    name = &amp;quot;${var.environment_name}-private&amp;quot;

    ingress {
        from_port   = 22
        to_port     = 22
        protocol    = &amp;quot;tcp&amp;quot;
        cidr_blocks = [&amp;quot;${var.vpc_public_subnet.cidr_block}&amp;quot;]
    }
(...)
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = &amp;quot;-1&amp;quot;
        cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
    }

    vpc_id = &amp;quot;${aws_vpc.development_environment.id}&amp;quot;
    tags {
        Name        = &amp;quot;${var.environment_name}-private-security-group&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ec2-instances&#34;&gt;EC2 Instances&lt;/h4&gt;

&lt;p&gt;With all the above resources declared we can finally define our EC2 instances.&lt;/p&gt;

&lt;p&gt;Our NAT instance and web proxy instance require an Elastic IP (resource &lt;strong&gt;&lt;em&gt;aws_eip&lt;/em&gt;&lt;/strong&gt;). We also need to choose an instance type for each EC2 instance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;instances-config.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;resource &amp;quot;aws_instance&amp;quot; &amp;quot;nat&amp;quot; {
    ami                         = &amp;quot;${var.nat.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.nat.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.nat.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.nat.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    associate_public_ip_address = true
    source_dest_check           = false

    tags {
        Name        = &amp;quot;${var.environment_name}-nat&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_eip&amp;quot; &amp;quot;nat&amp;quot; {
    instance = &amp;quot;${aws_instance.nat.id}&amp;quot;
    vpc      = true
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;web-proxy&amp;quot; {
    ami                         = &amp;quot;${var.web-proxy.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.web-proxy.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.web-proxy.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.public.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.public-subnet.id}&amp;quot;
    associate_public_ip_address = true
    source_dest_check           = true

    tags {
        Name        = &amp;quot;${var.environment_name}-web-proxy&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_eip&amp;quot; &amp;quot;web-proxy&amp;quot; {
  instance = &amp;quot;${aws_instance.web-proxy.id}&amp;quot;
  vpc      = true
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;database&amp;quot; {
    ami                         = &amp;quot;${var.database.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.database.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.database.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.private.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    associate_public_ip_address = false
    source_dest_check           = true

    tags {
        Name        = &amp;quot;${var.environment_name}-database&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}

resource &amp;quot;aws_instance&amp;quot; &amp;quot;service&amp;quot; {
    ami                         = &amp;quot;${var.services.ami_image}&amp;quot;
    availability_zone           = &amp;quot;${var.services.availability_zone}&amp;quot;
    instance_type               = &amp;quot;t2.micro&amp;quot;
    key_name                    = &amp;quot;${var.services.key_name}&amp;quot;
    security_groups             = [&amp;quot;${aws_security_group.private.id}&amp;quot;]
    subnet_id                   = &amp;quot;${aws_subnet.private-subnet.id}&amp;quot;
    associate_public_ip_address = false
    source_dest_check           = true
    count                       = 3

    tags {
        Name        = &amp;quot;${var.environment_name}-service-${count.index}&amp;quot;
        Environment = &amp;quot;${var.environment_name}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;instances-variables.tf&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;variable &amp;quot;nat&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-14913f63&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;web-proxy&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;database&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}

variable &amp;quot;services&amp;quot; {
    default = {
        ami_image         = &amp;quot;ami-2c90315b&amp;quot;
        availability_zone = &amp;quot;unknown&amp;quot;
        key_name          = &amp;quot;unknown&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verify&#34;&gt;Verify&lt;/h4&gt;

&lt;p&gt;Our VPC definition is now ready. But how do we know that everything is ready for provisioning? We can verify our all hard work. All we have to do is ask Terraform to prepare a plan by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform plan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform will combine all available files and prepare an execution plan. This means that all definitions will be verified before you start provisioning your resources. The output from this command will also give us an overview of the kind of operations that will be performed during execution of the plan.&lt;/p&gt;

&lt;p&gt;We have to remember that the plan only represents a dry run. We don&amp;rsquo;t connect to AWS at this point and we will not find any errors which might occur in the cloud. For example a plan will not show any errors if you have already exceeded your limit of available EC2 instances.&lt;/p&gt;

&lt;h3 id=&#34;apply&#34;&gt;Apply&lt;/h3&gt;

&lt;p&gt;So far we used only default values to run our plan. It is not particularly useful when you want to create real environment.&lt;/p&gt;

&lt;p&gt;To apply our execution plan we have to prepare a file which will contain the definitions of our variables. We can override default definitions by creating a file with extension &lt;strong&gt;&lt;em&gt;.tfvariables&lt;/em&gt;&lt;/strong&gt;. This file has the format of a regular Java property file where each key is the path of a variable and each value is the value assigned to it. An example variable file for our first environment might look like this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;my_first_vpc_environment.tfvariables&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;environment_name = &amp;quot;my_first_vpc_environment&amp;quot;

provider.access_key = &amp;quot;[MY_REAL_SECRET]&amp;quot;
provider.secret_key = &amp;quot;[MY_REAL_SECRET]&amp;quot;
provider.region = &amp;quot;eu-west-1&amp;quot;

vpc.owner_id   = &amp;quot;[MY_OWNER_ID]&amp;quot;
vpc.cidr_block = &amp;quot;10.0.0.0/16&amp;quot;

vpc_public_subnet.cidr_block         = &amp;quot;10.0.0.0/24&amp;quot;
vpc_public_subnet.availability_zone  = &amp;quot;eu-west-1a&amp;quot;

vpc_private_subnet.cidr_block        = &amp;quot;10.0.1.0/24&amp;quot;
vpc_private_subnet.availability_zone = &amp;quot;eu-west-1a&amp;quot;

nat.key_name                = &amp;quot;my_first_vpc_environment&amp;quot;
nat.availability_zone       = &amp;quot;eu-west-1a&amp;quot;

web-proxy.key_name          = &amp;quot;my_first_vpc_environment&amp;quot;
web-proxy.availability_zone = &amp;quot;eu-west-1a&amp;quot;

database.key_name           = &amp;quot;my_first_vpc_environment&amp;quot;
database.availability_zone  = &amp;quot;eu-west-1a&amp;quot;

services.key_name           = &amp;quot;my_first_vpc_environment&amp;quot;
services.availability_zone  = &amp;quot;eu-west-1a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify the plan again and if we decide that we are ready we can apply it by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform apply
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform will now connect to AWS and try to create all resources defined in Terraform scripts. The output of this command is a state file &lt;strong&gt;&lt;em&gt;terraform.tfstate&lt;/em&gt;&lt;/strong&gt; which contains all the information about the environment that we just provisioned. At the time of writing &lt;a href=&#34;https://www.terraform.io/docs/state/index.html&#34;&gt;the state file must be kept for future execution&lt;/a&gt; (e.g. in your version control system), because Terraform uses it to determine differences between cloud state and the current definition stored in your scripts.&lt;/p&gt;

&lt;h3 id=&#34;change&#34;&gt;Change&lt;/h3&gt;

&lt;p&gt;Sometimes we have to change our environment. It requires just a change in your definition config. Based on
the state of your existing environment and your updated configuration, Terraform is able to prepare a new plan and apply changes to your infrastructure.&lt;/p&gt;

&lt;p&gt;You can use the &lt;strong&gt;&lt;em&gt;plan&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;apply&lt;/em&gt;&lt;/strong&gt; commands in the same way as for a new environment. This time Terraform compares the state stored in the state file generated on the initial run, and plans/applies any newly-introduced changes to the configuration.&lt;/p&gt;

&lt;h3 id=&#34;destroy&#34;&gt;Destroy&lt;/h3&gt;

&lt;p&gt;Everything has to come to an end, sometime. When the time comes we can execute this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ terraform destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terraform once again reuses our state file and will remove all resources defined there.&lt;/p&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;In this post we only scratched the surface of Terraform. The AWS provider is one of &lt;a href=&#34;https://www.terraform.io/docs/providers/index.html&#34;&gt;many providers available&lt;/a&gt;. Terraform allows us to combine different providers which give the possibility of provisioning environments across multiple cloud providers.&lt;/p&gt;

&lt;p&gt;It also has other basic features. For example &lt;a href=&#34;https://www.terraform.io/docs/configuration/outputs.html&#34;&gt;outputs&lt;/a&gt; give you the possibility to generate files based on any available variables and resource properties. You can use it to generate documentation, config files or just human readable text files.&lt;/p&gt;

&lt;p&gt;Now our infrastructure can be managed in code. We can check it into source control, raise pull requests in GitHub and provide living documentation for our environment topology. We can lay the foundation for our deployments and tools like Puppet, Chef and Docker.&lt;/p&gt;

&lt;p&gt;All code examples described here can be found &lt;a href=&#34;https://github.com/robertfirek/ShapeYourInfrastructure&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>