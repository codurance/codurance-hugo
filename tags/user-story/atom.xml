<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>User Story on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/user-story/</link>
    <description>Recent content in User Story on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Fri, 20 Mar 2015 21:22:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/user-story/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>User Story Guidelines</title>
      <link>http://codurance.com/blog/user-stories-guidelines/</link>
      <pubDate>Fri, 20 Mar 2015 21:22:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/user-stories-guidelines/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Disclaimer: This post was extracted from an internal Codurance document used to help our apprentices to learn how we work. We all understand that each project is different and that by no means we can apply exactly the same techniques and practices everywhere. However, the text below serves not only as a foundation but also as a guideline for all of us when it comes to user stories. There are many good books and posts written about user stories. By no means this post is meant to be a summary of all the good practices around this area.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;User stories are a good way to gather requirements, agree on what needs to be done, and provide visibility of the work being done to clients. They also help us prioritise the work to be done according to the value they add at a given point in time.&lt;/p&gt;

&lt;p&gt;Below are a few guidelines in how we work with user stories.&lt;/p&gt;

&lt;h2 id=&#34;capturing-requirements&#34;&gt;Capturing requirements&lt;/h2&gt;

&lt;p&gt;The main objective of creating user stories is to understand what needs to be done. They document the expected behaviour that an application needs to provide. This is best achieved through a close collaboration between product owner (who represents the business needs and are in charge of priorities) , business analysts, QAs and the rest of the development team.&lt;/p&gt;

&lt;h2 id=&#34;user-story-lifecycle&#34;&gt;User story lifecycle&lt;/h2&gt;

&lt;p&gt;User stories start as an idea for the behaviour. This behaviour must also be associated to some value that will be added to the business once implemented.&lt;/p&gt;

&lt;p&gt;At first, a user story is just an idea and it only has a title describing the behaviour expected, with no details on. E.g. Music Player, Report fixed income trades, Display user feed. Product Owner elicits the stories from the business. Team members may also add stories to the product backlog in collaboration with the product owner.&lt;/p&gt;

&lt;p&gt;The Product Owner must prioritise the stories that the development team will work on in the next iteration. This is done by moving the stories to the top of the product backlog, in order of importance. This is done for just a few stories, not all. The stories at the top of the backlog have the highest business value at that point in time.&lt;/p&gt;

&lt;p&gt;Once stories are prioritised, they should be refined. At this point the Product Owner will start specifying the behaviour expected. They will enough details so that the developers have enough information to start implementing the story.&lt;/p&gt;

&lt;h2 id=&#34;user-story-refinement&#34;&gt;User story refinement&lt;/h2&gt;

&lt;p&gt;A story must have the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The value that it brings to the business (or specific actor/role)&lt;/li&gt;
&lt;li&gt;The detailed description of the behaviour expected, preferably with some examples, if applicable.&lt;/li&gt;
&lt;li&gt;The acceptance criteria, that means, everything that needs to be done by the development team so that the product owner can “accept” the story (agree that the story is done.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;user-story-template&#34;&gt;User story template&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;original&lt;/em&gt; template for a user story was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;As a &amp;lt;actor/role&amp;gt;
I would like to &amp;lt;desired action&amp;gt;
So that &amp;lt;business value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our preferred template is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In order to &amp;lt;get some value&amp;gt;
As a &amp;lt;actor/role&amp;gt;
I would like to &amp;lt;desired action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latter template helps us focus on the business value first. In many occasions, when using the default template, we were able to complete the first two steps and struggle to complete the third. The problem with not focusing on the third step is that we may end up building features that don’t really have any business value. Focusing on writing the business value first, forces us to discuss the real relevance of the story.&lt;/p&gt;

&lt;p&gt;Besides the business description, a story should be enriched with examples whenever possible.&lt;/p&gt;

&lt;p&gt;The final part is the Acceptance Criteria. This is where we describe details of the expected behaviour including the edge cases. The acceptance criteria is what is used by the product owner to “accept” a story. Acceptance Criteria is the ideal source for the automated tests.&lt;/p&gt;

&lt;h3 id=&#34;example-story-1-credit-card-payment&#34;&gt;Example Story 1: Credit Card Payment&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;In order to buy the items I need
As a customer
I would like to specify the credit card I want to use.

Acceptance criteria

* User must to have at least one item in the shopping basket in order to go to make the payment
* £2.00 fee should be added when amount to be paid is less than £10.00
* Accepted Credit Cards are: Visa, MasterCard, and American Express
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-story-2-playlists&#34;&gt;Example Story 2: Playlists&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;In order to easily find and listen to my favourite songs
As a music fan
I would like to organise my songs into playlists.

Acceptance criteria

* A playlist can be empty
* A song can be added to multiple playlists
* A song can only be added once to a playlist
* Playlists should have a unique name

Examples

| Playlist name | Songs                                 |
| Punk/Rock     | God Save The Queen, American Jesus    |
| Classic Rock  | Sultans of Swing, Sweet Child of Mine | 
| General       | Sultans of Swing, Censura             | 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;_Further reading: &lt;a href=&#34;http://en.wikipedia.org/wiki/Specification_by_example&#34;&gt;Specification by Example&lt;/a&gt;_&lt;/p&gt;

&lt;h2 id=&#34;breaking-stories-into-tasks&#34;&gt;Breaking stories into tasks&lt;/h2&gt;

&lt;p&gt;In order to estimate a story, developers should break down the stories into technical tasks. Each task should reflect a small and measurable piece of work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Task for Example Story 2: Playlists&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let’s assume we are building a web application with AngularJS in the front end and Java, Dropwizard, and MongoDB in the backend.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define the API used by the front end.&lt;/li&gt;
&lt;li&gt;UI changes for capturing a new playlist name (see mockup)&lt;/li&gt;
&lt;li&gt;Dropwizard endpoint for playlist creation&lt;/li&gt;
&lt;li&gt;Playlist service / repository interface&lt;/li&gt;
&lt;li&gt;Playlist persistence on MongoDB&lt;/li&gt;
&lt;li&gt;UI changes for adding songs to playlist (see mockup)&lt;/li&gt;
&lt;li&gt;Dropwizard endpoint for adding songs to playlist&lt;/li&gt;
&lt;li&gt;Persist songs added to playlist in MongoDB&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Should items 7 and 8 be part of this story? The short answer is &lt;em&gt;no&lt;/em&gt;. Although related, the tasks represent two different concepts: creating playlists and adding songs to playlists. More about that below.&lt;/p&gt;

&lt;h3 id=&#34;breaking-stories-in-to-smaller-stories&#34;&gt;Breaking stories in to smaller stories&lt;/h3&gt;

&lt;p&gt;Sometimes we know we need to break a story into smaller stories just looking at the name or description of it. E.g: Process a trade, Music player, etc. What type of trade? How many types do we have? Do they have different rules? Even processing a single trade can be massive. Do we need to enrich the data? Do we need to report the trade to different regulators? Do the trades come from a single source? Do they have the same format? We can also have loads of questions about a music player. Are we playing music that is stored locally? Are we streaming? If yes, from which sources? How many formats should we support? Should we be able to fast-forward, pause, and rewind? Do we start playing a song from where we stopped previously? Do we display any information about the song being played? If yes, where do we get the information from?&lt;/p&gt;

&lt;p&gt;As you can see, we cannot have a story that caters for an entire feature. Another way of putting it is, Processing a Trade and Music Player are not stories, they are features. Features are often referred to as epics however we believe that feature is a better term.&lt;/p&gt;

&lt;p&gt;When refining stories, it is our job as developers to ask all these questions to the product owners. Depending on the answers, we should create stories that will represent the different behaviours.&lt;/p&gt;

&lt;h4 id=&#34;what-happens-when-the-product-owner-doesn-t-know-the-answer&#34;&gt;What happens when the product owner doesn’t know the answer?&lt;/h4&gt;

&lt;p&gt;Well, there are a few possibilities here. Sometimes it is possible to help the product owner giving a few suggestions and explaining the cost/trade-offs of each one of them. Sometimes the whole team can just brainstorm ideas and pick one. However, depending on the domain, developers may not be equipped with enough business knowledge to even make suggestions. In these cases, we can create a story representing the behaviour being discussed and add it to the backlog. Whenever the product owner gets an answer, she will then prioritise that story or simply delete it from the backlog.&lt;/p&gt;

&lt;h2 id=&#34;estimation&#34;&gt;Estimation&lt;/h2&gt;

&lt;p&gt;There is a big debate about estimation. However, the debate is more about estimation in general, mainly big up-front estimation (search for #noestimates hashtag on Twitter for more.)&lt;/p&gt;

&lt;p&gt;We find the act of estimating top priority stories valuable, mainly in cases where the team is not mature enough (doesn’t master all the technologies used in the system, communication with business is not optimal, lack of business domain, etc.)&lt;/p&gt;

&lt;p&gt;Estimating a user story forces us to think about all the technical tasks we need to implement in order to complete the story. Once we have the list of tasks, we can then start estimating them in isolation. Let’s take the tasks for the Playlist story:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define the API used by the front end (2 hours)&lt;/li&gt;
&lt;li&gt;UI changes for capturing a new playlist name (3 hours)&lt;/li&gt;
&lt;li&gt;Dropwizard endpoint for playlist creation (2 hours)&lt;/li&gt;
&lt;li&gt;Playlist service / repository interface to add playlists (2 hours)&lt;/li&gt;
&lt;li&gt;Playlist persistence on MongoDB (1 hour)&lt;/li&gt;
&lt;li&gt;UI changes for adding songs to playlist (12 hours)&lt;/li&gt;
&lt;li&gt;Dropwizard endpoint for adding songs to playlist (2 hours)&lt;/li&gt;
&lt;li&gt;Persist songs added to playlist in MongoDB (1 hour)&lt;/li&gt;
&lt;li&gt;[ADDED] Playlist service / repository interface to add songs to play list (3 hours)&lt;/li&gt;
&lt;li&gt;[ADDED] Notification event that new playlist was created (2 hours)&lt;/li&gt;
&lt;li&gt;[ADDED] Notification event that song was added to playlist (2 hours)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;estimation-side-effects&#34;&gt;Estimation side-effects&lt;/h3&gt;

&lt;p&gt;When trying to estimate the tasks, we realised we forgot a few tasks (9, 10, and 11), so we added them. The total hours estimated for this story is 32 hours. Adding more tasks made it clear that this story must be split into two: create playlists and add songs to playlists.&lt;/p&gt;

&lt;p&gt;Another interesting thing about estimating this story is that we now noticed that if we count our days as if they only had 5 productive hours (uninterrupted coding hours), this story would take approximately 6.4 days. This is a little too big for a user story, which is another reason to break the story in two.&lt;/p&gt;

&lt;h4 id=&#34;how-small-is-small&#34;&gt;How small is small?&lt;/h4&gt;

&lt;p&gt;Think about Single Responsibility Principle (SRP). Yes, the one from SOLID. Our user stories should represent a single, small, and testable concept.&lt;/p&gt;

&lt;p&gt;As a guideline, a story should not be bigger than &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; (one third) of an iteration. That means, if you are working on a two-week iteration, stories should not be bigger than 3 days. Tasks, on the other hand, should not be bigger than half-day (2 to 4 hours.)&lt;/p&gt;

&lt;h2 id=&#34;spikes&#34;&gt;Spikes&lt;/h2&gt;

&lt;p&gt;Let’s take the following task as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5. Playlist persistence on MongoDB (1 hour)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this is the first task where we needed to use MongoDB and we never did any MongoDB persistence in the past, there is a chance that we don’t really know what we need to do and how long it is going to take. We need to research a little bit, maybe even try a few things out before we can estimate the task.&lt;/p&gt;

&lt;p&gt;That’s what spikes are for. Spikes are a time-boxed investigation activity where the outcome of it is documenting the results of the investigation and also stories and tasks refinements, including estimations. Once we spend a day or two investigating how to install, connect, and store data on MongoDB, we are in a better position create/adjust tasks and estimate them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spikes should not be done as part of a story&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spikes are done in isolation, never as part of a story. If the story depends on the investigation done by the spike, the spike should be prioritised and the story should remain on the backlog. Once the spike is done, the story can then be refined and scheduled to the following iteration.&lt;/p&gt;

&lt;p&gt;Spike is a special type of story where the value is a better understanding of what or how something can be achieved.&lt;/p&gt;

&lt;h2 id=&#34;technical-stories&#34;&gt;Technical stories&lt;/h2&gt;

&lt;p&gt;Generally, they should be avoided. We should only have stories that provide business value. Technical tasks should be added to business stories instead. The reason for that is to always focus on delivering value to our customers instead of going crazy with architecture and infrastructure.&lt;/p&gt;

&lt;h3 id=&#34;when-to-use-technical-stories&#34;&gt;When to use technical stories&lt;/h3&gt;

&lt;p&gt;Technical stories are quite common at the beginning of a project. There are many things that need to be in place before we start working. E.g. Continuous Integration, UAT/Test environment, source control, etc. There is also loads of infrastructure/architecture work that needs to be done in order to satisfy the first stories. E.g. Create databases, package and deploy the application, etc. On top of that, there are always non-functional requirements that also need to be met. E.g.: performance, security, logging, etc.&lt;/p&gt;

&lt;h4 id=&#34;express-business-value&#34;&gt;Express business value&lt;/h4&gt;

&lt;p&gt;Technical stories cannot be ignored. However, when writing them, we need to express the business value they bring. E.g. Protect users data, support a bigger number of concurrent users, improve the user experience with better response time, etc.&lt;/p&gt;

&lt;p&gt;Expressing the business value of a technical story is extremely important. This gives the business a better understanding of why certain things need to be done. Business can also analyse the risks of not doing certain things and prioritise them accordingly.&lt;/p&gt;

&lt;h3 id=&#34;technical-versus-business-stories&#34;&gt;Technical versus Business stories&lt;/h3&gt;

&lt;p&gt;Whenever possible, we should not have infrastructure/architectural tasks inside business stories. E.g. We should not have a task related to add databases to a cluster in a business story about creating a client.&lt;/p&gt;

&lt;p&gt;Non-functional requirements like performance improvement, caches, clusters, communication protocols, should have their own technical stories.&lt;/p&gt;

&lt;h2 id=&#34;i-n-v-e-s-t&#34;&gt;I.N.V.E.S.T.&lt;/h2&gt;

&lt;p&gt;The INVEST mnemonic was created by Bill Wake as a reminder of the characteristics of a good quality user story, as may be used in a Scrum backlog or XP project.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt;ndependent:   The user story should be self-contained, in a way that there is no inherent dependency on another user story.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;egotiable:   User stories, up until they are part of an iteration, can always be changed and rewritten.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;aluable: A user story must deliver value to the end user.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;stimable:    You must always be able to estimate the size of a user story.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;calable (small sized):   User stories should not be so big as to become impossible to plan/task/prioritize with a certain level of certainty.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt;estable: The user story or its related description must provide the necessary information to make test development possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more about INVEST, check its &lt;a href=&#34;http://en.wikipedia.org/wiki/INVEST_%28mnemonic%29&#34;&gt;wikipedia page&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-should-we-care-about-all-these&#34;&gt;Why should we care about all these?&lt;/h2&gt;

&lt;p&gt;There are a few reasons to why we do all the things described above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Visibility:&lt;/strong&gt; Working in small increments provides good visibility of what has been done, what is being done, and what is left to be done. Tasks and stories are constantly on the move, navigating quickly through the different lanes in our Scrum boards, from &lt;em&gt;TO DO&lt;/em&gt; to &lt;em&gt;DONE&lt;/em&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Feedback:&lt;/strong&gt; Business and development team have a constant feedback of how things are going. This allows both to react quickly and change priorities. If something goes wrong with a story, we may only loose a few hours or days of work and not weeks or months.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Team morale:&lt;/strong&gt; Morale is always up when we constantly achieve goals, that means, moving tasks and stories to done.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agility:&lt;/strong&gt; Working in small batches allow us to deploy often, get feedback quickly, and adapt when necessary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Team organisation:&lt;/strong&gt; With well-define and small stories and tasks, it is easier to split and parallelise work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;This post was written by Sandro Mancuso in collaboration with Mashooq Badar.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Defining and Prioritising a Backlog</title>
      <link>http://codurance.com/blog/defining-and-prioritising-a-backlog/</link>
      <pubDate>Thu, 03 Jun 2010 14:58:45 +0000</pubDate>
      
      <guid>http://codurance.com/blog/defining-and-prioritising-a-backlog/</guid>
      <description>&lt;p&gt;What is the best way to review a backlog? How do you ensure that it is &amp;ldquo;complete&amp;rdquo;? How do you ensure that the prioritisation reflects the business vision and goals?&lt;/p&gt;

&lt;p&gt;When first faced with a backlog, you are often overwhelmed by the long list of userstories. The most important step is to set a context for these userstories. Are these userstories organised in a hierarchy of “epics”? This hierarchy will help set a context. But first we need to understand what these epics mean at the highest level. Do they represent a user’s high-level goals or are they merely there as a container for some loosely related stories?&lt;/p&gt;

&lt;p&gt;When reviewing a backlog for completion it is vitally important that the stories are defined in a context. The context can take different forms depending on the nature of the application. For example if an application has a clear high-level flow that the user journeys along then the epics may be defined as activities in this flow and the userstories can be grouped under each epic representing the functionality required for this activity. This &lt;a href=&#34;//www.agileproductdesign.com/blog/the_new_backlog.html&#34;&gt;article&lt;/a&gt; by Jeff Patton presents such an approach. However, your application my exhibit a more random usage scenario. In this case epics representing high-level user goals may represent the best context for the stories. You can also provide references to other artefacts such as user journeys/wireframes to further enrich the context. This &lt;a href=&#34;//tynerblain.com/blog/2009/07/06/writing-complete-user-stories&#34;&gt;article&lt;/a&gt; by Scott Sehlhorst is an interesting discussion of setting a context for user stories.&lt;/p&gt;

&lt;p&gt;This grouping of userstories by a context also helps to manage their prioritisation. You can individually prioritise stories within each epic and then also prioritise the epics. Note that just because one epic has a higher priority does not mean that all its child userstories are of a higher priority. You may discover that only the first few userstories can provide enough functionality that further work on that epic is of a lower priority then working on another epic.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Userstories and when enough is enough</title>
      <link>http://codurance.com/blog/userstories-and-when-enough-is-enough/</link>
      <pubDate>Tue, 14 Apr 2009 13:33:23 +0000</pubDate>
      
      <guid>http://codurance.com/blog/userstories-and-when-enough-is-enough/</guid>
      <description>&lt;p&gt;Perfection in software is impossible. Software developement is subject to the Law of Diminishing Returns . So how do you decide when enough is enhough?&lt;/p&gt;

&lt;p&gt;In a recent presentation Al Goerner discussed catagorising stories. Two of the more interesting catagories were &amp;ldquo;New feature&amp;rdquo; and &amp;ldquo;Feature enhancement&amp;rdquo;. In an Agile project where new stories are constantly being added to the backlog, these two catagories can help use decide when a product is maturing and the new stories coming into the backlog are simply tweaks to the original requirements. In general &amp;ldquo;Feature Enhancements&amp;rdquo; provide a much smaller &amp;ldquo;bang for your buck&amp;rdquo; then &amp;ldquo;New Features&amp;rdquo;. A simple rule of thumb is that when your backlog is mostly &amp;ldquo;Feature enahncements&amp;rdquo; then it is time to re-evaluate the ROI for continuing developement and compare it with the opertunitiy cost of a new endeavour.&lt;/p&gt;

&lt;p&gt;Catagorising stories can also help us manage Risk and Issues within our backlog.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>