<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Threading on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/threading/</link>
    <description>Recent content in Threading on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 15 Jul 2014 12:00:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/threading/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Queue Based Synchronisation</title>
      <link>http://codurance.com/blog/queue-based-synchronisation/</link>
      <pubDate>Tue, 15 Jul 2014 12:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/queue-based-synchronisation/</guid>
      <description>&lt;p&gt;The first rule of using locks for thread synchronisation is, &lt;strong&gt;&amp;ldquo;Do NOT use them!&amp;rdquo;&lt;/strong&gt;. Recently I saw an implementation that made heavy use of locks to synchronise access to a shared cache between two threads. The overall approach is explained in the diagram below:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/lock-based-synchronisation.jpg&#34; alt=&#34;Lock based synchronisation&#34; title=&#34;Lock based synchronisation&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Why not do the whole thing in a single thread? Well! the operations to the External Store are very time consuming and Thread-1 does not need to wait for them. So how do you solve this without using lock-based synchronisation?&lt;/p&gt;

&lt;p&gt;The operations to the cache are very quick and can be done in a single thread. These operations are coming from multiple threads. We can funnel them through a single thread by using a thread-safe queue as explained in the following diagram:&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/queue-based-synchronisation.jpg&#34; alt=&#34;Queue based synchronisation&#34; title=&#34;Queue based synchronisation&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;Although this solution looks more complicated, the key advantage is that no low-level thread synchronisation is needed. Most good programming languages already provide thread-safe queues. Also, you can scale up using a thread pool for the operations to the external store.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: in both of the above approaches we need to ensure that the cache does not grow indefinitely. In case of the queue based approach we can use a a queue that blocks after a maximum capacity is reached. In case of the lock based approach the cache itself will need to block.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>