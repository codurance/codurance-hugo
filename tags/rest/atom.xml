<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rest on Software Craftsmanship and Agile Development</title>
    <link>http://codurance.com/tags/rest/</link>
    <description>Recent content in Rest on Software Craftsmanship and Agile Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Thu, 22 Oct 2015 00:20:00 +0000</lastBuildDate>
    <atom:link href="http://codurance.com/tags/rest/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Transcending REST and RPC</title>
      <link>http://codurance.com/blog/Transcending-rest-and-rpc/</link>
      <pubDate>Thu, 22 Oct 2015 00:20:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/Transcending-rest-and-rpc/</guid>
      <description>

&lt;p&gt;It seems that a new paradigm is coming. Facebook and Netflix have come up with different implementations for that idea. Some people are calling it &lt;a href=&#34;http://www.infoq.com/presentations/domain-driven-architecture&#34;&gt;Demand-Driven Architecture&lt;/a&gt;, but before I show you some solutions, let&amp;rsquo;s go over some history to understand the problem. I will use the example that Netflix provides, but I think that most of us will find the patterns familiar.&lt;/p&gt;

&lt;p&gt;Just for clarity, let&amp;rsquo;s assume that we have an on-demand streaming service &amp;ndash; quite similar to Netflix :) &amp;ndash; that has three microservices. One contains the genres, another one the titles and the last one contains the ratings that different users give to those titles. As we&amp;rsquo;re in 2015 we&amp;rsquo;ll discard RPC as architectural style and we&amp;rsquo;ll go with a RESTful design. Let&amp;rsquo;s briefly enumerate the characteristics of a RESTful design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP verbs have direct correspondence with CRUD verbs. One of the benefits is that clients can understand what is going on the server without digging into the implementation. For instance, we know that PUT is idempotent, so as there will not be any side effect, the client can call to that endpoint several times in a row without any issue.&lt;/li&gt;
&lt;li&gt;We use extensive HTTP caching. Through headers like Cache-Control or ETag, we leverage one of the most juicy features of HTTP: caching resources.&lt;/li&gt;
&lt;li&gt;HATEOAS for the win. Every single representation should have links to different representations so the clients can navigate through our backend like a graph.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.restapitutorial.com/&#34;&gt;Further reading&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rest-limitations&#34;&gt;REST limitations&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s imagine that we send a GET to the genres endpoint. The response will include links to other GET requests like titles/1234 or ratings/6789. If we have the title &amp;ldquo;Titanic&amp;rdquo; in different genres (romance, drama and DiCaprioRules) you can see how the client is going to do at least two redundant requests. Apart from that the client is going to reshape the data whenever it comes back since it&amp;rsquo;s likely that the client won&amp;rsquo;t need every single field that those responses include. So, we have two problems with this design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;High latency as we don&amp;rsquo;t optimize calls.&lt;/li&gt;
&lt;li&gt;Large message sizes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;patching-rest-with-rpc&#34;&gt;Patching REST with RPC&lt;/h2&gt;

&lt;p&gt;One way of overcoming these problems is customising our requests with query params. You can say to the server something like &amp;ldquo;&lt;em&gt;give me only a couple of the fields that you expose on that representation&lt;/em&gt;&amp;rdquo;&amp;rdquo; or whatever arbitrary parameter. That means that you&amp;rsquo;ll lose the caching that HTTP offers as now you&amp;rsquo;ll have a ton of possible &lt;em&gt;not-really-resources&lt;/em&gt; to cache.&lt;/p&gt;

&lt;p&gt;Also you can create new abstractions ad-hoc that aggregate that for the client. In fact one of the benefits of CQRS is being able to create different views of your internal entities, so the demands of the client doesn&amp;rsquo;t affect your domain modeling. That has a problem though: there is a big a coupling with the server. Our system has a massive amount of fragmentation as you can stream over Android, iOS, TVs and also, different versions of the same client device. Therefore there are going to be different needs and rhythms and the coordination between backend and clients is going to be really messy.&lt;/p&gt;

&lt;p&gt;Also, CQRS is amazing in the fact that you could decide to model your system around different bounded contexts, i.e, different CQRS deployables. If your client needs a view that aggregate data from two CQRS units, you have the same problem.&lt;/p&gt;

&lt;h2 id=&#34;demand-driven-architecture-to-the-rescue&#34;&gt;Demand driven architecture to the rescue&lt;/h2&gt;

&lt;p&gt;This leads to the point of Demand Driven Architectures. Conceptually the backend is just a single entity and, since it&amp;rsquo;s modeled using REST principles, it&amp;rsquo;s defining what is the shape of the data. However, we&amp;rsquo;re going to have tons of clients with different needs and all of them need to twist themselves in order to get the shape of the data that they want. Would it be great if clients could just send queries to the logical data unit called backend?&lt;/p&gt;

&lt;p&gt;If we think in a relational database the concept is similar. We have different tables (rest endpoints, resources, backend services) and we have a query language that allows us to join and shape the data easily. Some of the optimizations of that query will be done by the platform that runs those queries.&lt;/p&gt;

&lt;h2 id=&#34;falcor-and-json-graph&#34;&gt;Falcor and JSON Graph&lt;/h2&gt;

&lt;p&gt;Netflix has created a tool called &lt;a href=&#34;http://netflix.github.io/falcor&#34;&gt;Falcor&lt;/a&gt; that tries to solve this concrete problem. Clients won&amp;rsquo;t talk with the backend services directly anymore, instead of they will send queries to a Falcor service that will do the routing, aggregations, projections and optimizations. This is an image from Falcor&amp;rsquo;s official documentation.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/falcor-network-diagram.png&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;They based that platform on the idea of JSON Graph. Let me explain it briefly. JSON is in essence a tree structure. However, most of our data has relationships so it should be modeled like a graph. Using REST design programmers usually solve that problem through ids, but that makes our life really difficult (think about problems like cache invalidation). As they say:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JSON Graph is valid JSON and can be parsed by any JSON parser. However JSON Graph introduces new primitive types to JSON to allow JSON to be used to represent graph information in a simple and consistent way.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;They borrow the idea from unix filesystem. That filesystem is a tree, but thanks to symlinks you can emulate the behaviour of a graph. That has massive implications in the way that Falcor optimises calls to backend services. Instead of keeping some values in a denormalised fashion, Falcor keeps references to that normalised value, so, if you ask for a value that has been already retrieved, Falcor will avoid that call. Also That makes cache invalidation much easier.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/falcor-services-diagram.png&#34;  class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;As you can see in the example, we don&amp;rsquo;t store denormalised documents for titles inside of genres, but a reference through a titles map indexed by id.
I can show you some code that I&amp;rsquo;ve been working on for a proof of concept. Falcor server side is currently only available on Node.js but &lt;a href=&#34;https://twitter.com/falcorjs/status/575657256475189248&#34;&gt;there are plans to porting it into another platforms&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;router.get(&#39;/model.json&#39;, falcorKoa.dataSourceRoute(new FalcorRouter([
		{
			route: &amp;quot;teamsById[{integers:teamIds}][&#39;name&#39;, &#39;memberCount&#39;]&amp;quot;,
			get  : function(pathSet) {
				const teamIds = pathSet.teamIds;
				const keys = pathSet[2];
				return teamsService.getTeams()
						.then(function(teams) {
							var results = [];
							teamIds.forEach(function(teamId) {
								keys.forEach(function(key) {
									var team = teams[teamId];
									results.push({
										path : [&#39;team&#39;, teamId, key],
										value: team[key]
									});
								});
							});
							return results;
						});
			}
		}
	])));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The client side would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const model = new falcor.Model({ source: new falcor.HttpDataSource(&#39;/model.json&#39;) });
model.get(&#39;teamsById[&#39;1234&#39;, &#39;456&#39;].name&#39;);
model.get(&#39;teamsById[&#39;789&#39;][&#39;name&#39;, &#39;memberCount&#39;]&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;in-conclusion&#34;&gt;IN CONCLUSION&lt;/h2&gt;

&lt;p&gt;There are no silver bullets in software and nobody is claiming than Falcor or GraphQL are going to solve every single problem with client/server integration. However, if you have an application with a lot of clients and your backend has a complex data model, it might be worth giving this new paradigm a try.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://netflix.github.io/falcor&#34;&gt;Falcor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html&#34;&gt;GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/presentations/domain-driven-architecture&#34;&gt;Demand-Driven Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Clojure (Prismatic) Schemas are Swagger</title>
      <link>http://codurance.com/blog/clojure-schemas-are-swagger/</link>
      <pubDate>Mon, 14 Sep 2015 13:00:00 +0000</pubDate>
      
      <guid>http://codurance.com/blog/clojure-schemas-are-swagger/</guid>
      <description>&lt;p&gt;Recently, I decided to include Swagger documentation to our time sheet application. Although Swagger provides tools to help clients integrate with your REST API the most powerful feature, in my opinion, is that it acts as &amp;ldquo;living documentation&amp;rdquo; for the API. Adding Swagger to my the application had a couple of pleasant side-effects:&lt;/p&gt;

&lt;p&gt;Idiomatic Clojure encourages the use of data structures such as maps. This work really well because JSON to/from Clojure Map translation, and persistence becomes straight forward whether you are using the &lt;a href=&#34;https://github.com/clojure/java.jdbc&#34;&gt;org.clojure/java.jdbc&lt;/a&gt; or persisting to a document database such as MongoDB. However, The problem with this approach is that understanding your entities becomes difficult. You often need to resort to the DDL for this purpose and in case of some databases you may not even have that. In cases where you are using migrations - your DDL may be scattered across many migrations over time. The Swagger support provided by &lt;a href=&#34;https://github.com/metosin/compojure-api&#34;&gt;metosin/compojure-api&lt;/a&gt; uses &lt;a href=&#34;https://github.com/Prismatic/schema&#34;&gt;prismatic/schema&lt;/a&gt; to define your API. Here is an example of what Activity and a list of Activities looks like in my time sheet application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(def Activity {
  :id s/Num
  :name s/Str
  :description s/Str
  :activitytype (s/enum &amp;quot;Daily&amp;quot; &amp;quot;Hourly&amp;quot;) })

(def Activities [Activity])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prismatic Schema provides other features such as attribute optionality, value optionality, custom schema types etc. See &lt;a href=&#34;https://github.com/Prismatic/schema&#34;&gt;README&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;Now that I have a single place where I can go to fully understand how my entities/value-objects looks like. The same entities/value-objects are used in my route definitions to define the REST API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(GET* &amp;quot;/activity&amp;quot; []
  :return Activities
  :summary &amp;quot;All activities in the system&amp;quot;
  (ok (auth #(controller/get-activities))))

(PUT* &amp;quot;/activity&amp;quot; []
  :body [activity Activity]
  :summary &amp;quot;Update an activity&amp;quot;
  (ok (auth #(controller/update-activity activity))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I am creating two routes for GET and PUT HTTP requests. In case of GET, I will return Activities and in case of PUT I expect an Activity in the body and return nothing. In both cases I return a HTTP OK code. The &amp;lsquo;auth&amp;rsquo; call allows me to authenticate the user before the call to the controller is made. The Compojure API can generate the full Swagger UI, allowing client developers to explore and invoke the API (if they have the right access of course!).&lt;/p&gt;

&lt;p&gt;The generated Swagger UI looks like the following.&lt;/p&gt;


&lt;img src=&#34;http://codurance.com/assets/img/custom/blog/2015-09-14-swagger-clojure/swagger-doc.png&#34; alt=&#34;Generated Swagger Documentation&#34; title=&#34;Generated Swagger Documentation&#34; class=&#34;img img-responsive style-screengrab&#34;/&gt;


&lt;p&gt;The Compojure API validates every request/response against the model so that any violation of the API will result in a failure. This brings me to the second side-effect; you can validate the model against your tests! In my case I validate the model against my controllers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(defn ^:always-validate get-activities :- Activities []
  (model/get-activities))

(defn ^:always-validate update-activity [activity :- Activity]
  (model/update-activity activity))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;^:always-validate&lt;/code&gt; meta data will validate my tests against the model. In this case my functional tests are testing the system from controllers to the database allowing me to enforce the schema at build time.&lt;/p&gt;

&lt;p&gt;Clojure is a dynamic language. One of its main criticisms is a lack of types. Although there is some good work in progress by the &lt;a href=&#34;http://typedclojure.org/&#34;&gt;Typed Clojure&lt;/a&gt; project, I think the Prismatic Schema library provides a very good compromise and the fact that it plays nicely with Swagger is an icing on the cake.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>